
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Employee
 * 
 */
export type Employee = $Result.DefaultSelection<Prisma.$EmployeePayload>
/**
 * Model Contract
 * 
 */
export type Contract = $Result.DefaultSelection<Prisma.$ContractPayload>
/**
 * Model AvailabilityInterval
 * 
 */
export type AvailabilityInterval = $Result.DefaultSelection<Prisma.$AvailabilityIntervalPayload>
/**
 * Model TimeRecord
 * 
 */
export type TimeRecord = $Result.DefaultSelection<Prisma.$TimeRecordPayload>
/**
 * Model Shift
 * 
 */
export type Shift = $Result.DefaultSelection<Prisma.$ShiftPayload>
/**
 * Model DayLock
 * 
 */
export type DayLock = $Result.DefaultSelection<Prisma.$DayLockPayload>
/**
 * Model PayPeriod
 * 
 */
export type PayPeriod = $Result.DefaultSelection<Prisma.$PayPeriodPayload>
/**
 * Model Amendment
 * 
 */
export type Amendment = $Result.DefaultSelection<Prisma.$AmendmentPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const ContractStatus: {
  EN_CONTRAT: 'EN_CONTRAT',
  DEMISSION: 'DEMISSION',
  AUTRE: 'AUTRE'
};

export type ContractStatus = (typeof ContractStatus)[keyof typeof ContractStatus]


export const Sex: {
  Homme: 'Homme',
  Femme: 'Femme'
};

export type Sex = (typeof Sex)[keyof typeof Sex]


export const DayOfWeek: {
  Lundi: 'Lundi',
  Mardi: 'Mardi',
  Mercredi: 'Mercredi',
  Jeudi: 'Jeudi',
  Vendredi: 'Vendredi',
  Samedi: 'Samedi',
  Dimanche: 'Dimanche'
};

export type DayOfWeek = (typeof DayOfWeek)[keyof typeof DayOfWeek]

}

export type ContractStatus = $Enums.ContractStatus

export const ContractStatus: typeof $Enums.ContractStatus

export type Sex = $Enums.Sex

export const Sex: typeof $Enums.Sex

export type DayOfWeek = $Enums.DayOfWeek

export const DayOfWeek: typeof $Enums.DayOfWeek

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Employees
 * const employees = await prisma.employee.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Employees
   * const employees = await prisma.employee.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.employee`: Exposes CRUD operations for the **Employee** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Employees
    * const employees = await prisma.employee.findMany()
    * ```
    */
  get employee(): Prisma.EmployeeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contract`: Exposes CRUD operations for the **Contract** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contracts
    * const contracts = await prisma.contract.findMany()
    * ```
    */
  get contract(): Prisma.ContractDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.availabilityInterval`: Exposes CRUD operations for the **AvailabilityInterval** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AvailabilityIntervals
    * const availabilityIntervals = await prisma.availabilityInterval.findMany()
    * ```
    */
  get availabilityInterval(): Prisma.AvailabilityIntervalDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.timeRecord`: Exposes CRUD operations for the **TimeRecord** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TimeRecords
    * const timeRecords = await prisma.timeRecord.findMany()
    * ```
    */
  get timeRecord(): Prisma.TimeRecordDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.shift`: Exposes CRUD operations for the **Shift** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Shifts
    * const shifts = await prisma.shift.findMany()
    * ```
    */
  get shift(): Prisma.ShiftDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.dayLock`: Exposes CRUD operations for the **DayLock** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DayLocks
    * const dayLocks = await prisma.dayLock.findMany()
    * ```
    */
  get dayLock(): Prisma.DayLockDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payPeriod`: Exposes CRUD operations for the **PayPeriod** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PayPeriods
    * const payPeriods = await prisma.payPeriod.findMany()
    * ```
    */
  get payPeriod(): Prisma.PayPeriodDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.amendment`: Exposes CRUD operations for the **Amendment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Amendments
    * const amendments = await prisma.amendment.findMany()
    * ```
    */
  get amendment(): Prisma.AmendmentDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.5.0
   * Query Engine version: 173f8d54f8d52e692c7e27e72a88314ec7aeff60
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Employee: 'Employee',
    Contract: 'Contract',
    AvailabilityInterval: 'AvailabilityInterval',
    TimeRecord: 'TimeRecord',
    Shift: 'Shift',
    DayLock: 'DayLock',
    PayPeriod: 'PayPeriod',
    Amendment: 'Amendment'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "employee" | "contract" | "availabilityInterval" | "timeRecord" | "shift" | "dayLock" | "payPeriod" | "amendment"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Employee: {
        payload: Prisma.$EmployeePayload<ExtArgs>
        fields: Prisma.EmployeeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmployeeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmployeeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          findFirst: {
            args: Prisma.EmployeeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmployeeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          findMany: {
            args: Prisma.EmployeeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>[]
          }
          create: {
            args: Prisma.EmployeeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          createMany: {
            args: Prisma.EmployeeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmployeeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>[]
          }
          delete: {
            args: Prisma.EmployeeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          update: {
            args: Prisma.EmployeeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          deleteMany: {
            args: Prisma.EmployeeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmployeeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EmployeeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>[]
          }
          upsert: {
            args: Prisma.EmployeeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          aggregate: {
            args: Prisma.EmployeeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmployee>
          }
          groupBy: {
            args: Prisma.EmployeeGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmployeeGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmployeeCountArgs<ExtArgs>
            result: $Utils.Optional<EmployeeCountAggregateOutputType> | number
          }
        }
      }
      Contract: {
        payload: Prisma.$ContractPayload<ExtArgs>
        fields: Prisma.ContractFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContractFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContractFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload>
          }
          findFirst: {
            args: Prisma.ContractFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContractFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload>
          }
          findMany: {
            args: Prisma.ContractFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload>[]
          }
          create: {
            args: Prisma.ContractCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload>
          }
          createMany: {
            args: Prisma.ContractCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContractCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload>[]
          }
          delete: {
            args: Prisma.ContractDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload>
          }
          update: {
            args: Prisma.ContractUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload>
          }
          deleteMany: {
            args: Prisma.ContractDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContractUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ContractUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload>[]
          }
          upsert: {
            args: Prisma.ContractUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload>
          }
          aggregate: {
            args: Prisma.ContractAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContract>
          }
          groupBy: {
            args: Prisma.ContractGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContractGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContractCountArgs<ExtArgs>
            result: $Utils.Optional<ContractCountAggregateOutputType> | number
          }
        }
      }
      AvailabilityInterval: {
        payload: Prisma.$AvailabilityIntervalPayload<ExtArgs>
        fields: Prisma.AvailabilityIntervalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AvailabilityIntervalFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvailabilityIntervalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AvailabilityIntervalFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvailabilityIntervalPayload>
          }
          findFirst: {
            args: Prisma.AvailabilityIntervalFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvailabilityIntervalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AvailabilityIntervalFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvailabilityIntervalPayload>
          }
          findMany: {
            args: Prisma.AvailabilityIntervalFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvailabilityIntervalPayload>[]
          }
          create: {
            args: Prisma.AvailabilityIntervalCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvailabilityIntervalPayload>
          }
          createMany: {
            args: Prisma.AvailabilityIntervalCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AvailabilityIntervalCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvailabilityIntervalPayload>[]
          }
          delete: {
            args: Prisma.AvailabilityIntervalDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvailabilityIntervalPayload>
          }
          update: {
            args: Prisma.AvailabilityIntervalUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvailabilityIntervalPayload>
          }
          deleteMany: {
            args: Prisma.AvailabilityIntervalDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AvailabilityIntervalUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AvailabilityIntervalUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvailabilityIntervalPayload>[]
          }
          upsert: {
            args: Prisma.AvailabilityIntervalUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvailabilityIntervalPayload>
          }
          aggregate: {
            args: Prisma.AvailabilityIntervalAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAvailabilityInterval>
          }
          groupBy: {
            args: Prisma.AvailabilityIntervalGroupByArgs<ExtArgs>
            result: $Utils.Optional<AvailabilityIntervalGroupByOutputType>[]
          }
          count: {
            args: Prisma.AvailabilityIntervalCountArgs<ExtArgs>
            result: $Utils.Optional<AvailabilityIntervalCountAggregateOutputType> | number
          }
        }
      }
      TimeRecord: {
        payload: Prisma.$TimeRecordPayload<ExtArgs>
        fields: Prisma.TimeRecordFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TimeRecordFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeRecordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TimeRecordFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeRecordPayload>
          }
          findFirst: {
            args: Prisma.TimeRecordFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeRecordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TimeRecordFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeRecordPayload>
          }
          findMany: {
            args: Prisma.TimeRecordFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeRecordPayload>[]
          }
          create: {
            args: Prisma.TimeRecordCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeRecordPayload>
          }
          createMany: {
            args: Prisma.TimeRecordCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TimeRecordCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeRecordPayload>[]
          }
          delete: {
            args: Prisma.TimeRecordDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeRecordPayload>
          }
          update: {
            args: Prisma.TimeRecordUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeRecordPayload>
          }
          deleteMany: {
            args: Prisma.TimeRecordDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TimeRecordUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TimeRecordUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeRecordPayload>[]
          }
          upsert: {
            args: Prisma.TimeRecordUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeRecordPayload>
          }
          aggregate: {
            args: Prisma.TimeRecordAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTimeRecord>
          }
          groupBy: {
            args: Prisma.TimeRecordGroupByArgs<ExtArgs>
            result: $Utils.Optional<TimeRecordGroupByOutputType>[]
          }
          count: {
            args: Prisma.TimeRecordCountArgs<ExtArgs>
            result: $Utils.Optional<TimeRecordCountAggregateOutputType> | number
          }
        }
      }
      Shift: {
        payload: Prisma.$ShiftPayload<ExtArgs>
        fields: Prisma.ShiftFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ShiftFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ShiftFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload>
          }
          findFirst: {
            args: Prisma.ShiftFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ShiftFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload>
          }
          findMany: {
            args: Prisma.ShiftFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload>[]
          }
          create: {
            args: Prisma.ShiftCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload>
          }
          createMany: {
            args: Prisma.ShiftCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ShiftCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload>[]
          }
          delete: {
            args: Prisma.ShiftDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload>
          }
          update: {
            args: Prisma.ShiftUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload>
          }
          deleteMany: {
            args: Prisma.ShiftDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ShiftUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ShiftUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload>[]
          }
          upsert: {
            args: Prisma.ShiftUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload>
          }
          aggregate: {
            args: Prisma.ShiftAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateShift>
          }
          groupBy: {
            args: Prisma.ShiftGroupByArgs<ExtArgs>
            result: $Utils.Optional<ShiftGroupByOutputType>[]
          }
          count: {
            args: Prisma.ShiftCountArgs<ExtArgs>
            result: $Utils.Optional<ShiftCountAggregateOutputType> | number
          }
        }
      }
      DayLock: {
        payload: Prisma.$DayLockPayload<ExtArgs>
        fields: Prisma.DayLockFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DayLockFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DayLockPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DayLockFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DayLockPayload>
          }
          findFirst: {
            args: Prisma.DayLockFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DayLockPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DayLockFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DayLockPayload>
          }
          findMany: {
            args: Prisma.DayLockFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DayLockPayload>[]
          }
          create: {
            args: Prisma.DayLockCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DayLockPayload>
          }
          createMany: {
            args: Prisma.DayLockCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DayLockCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DayLockPayload>[]
          }
          delete: {
            args: Prisma.DayLockDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DayLockPayload>
          }
          update: {
            args: Prisma.DayLockUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DayLockPayload>
          }
          deleteMany: {
            args: Prisma.DayLockDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DayLockUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DayLockUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DayLockPayload>[]
          }
          upsert: {
            args: Prisma.DayLockUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DayLockPayload>
          }
          aggregate: {
            args: Prisma.DayLockAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDayLock>
          }
          groupBy: {
            args: Prisma.DayLockGroupByArgs<ExtArgs>
            result: $Utils.Optional<DayLockGroupByOutputType>[]
          }
          count: {
            args: Prisma.DayLockCountArgs<ExtArgs>
            result: $Utils.Optional<DayLockCountAggregateOutputType> | number
          }
        }
      }
      PayPeriod: {
        payload: Prisma.$PayPeriodPayload<ExtArgs>
        fields: Prisma.PayPeriodFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PayPeriodFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayPeriodPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PayPeriodFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayPeriodPayload>
          }
          findFirst: {
            args: Prisma.PayPeriodFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayPeriodPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PayPeriodFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayPeriodPayload>
          }
          findMany: {
            args: Prisma.PayPeriodFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayPeriodPayload>[]
          }
          create: {
            args: Prisma.PayPeriodCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayPeriodPayload>
          }
          createMany: {
            args: Prisma.PayPeriodCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PayPeriodCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayPeriodPayload>[]
          }
          delete: {
            args: Prisma.PayPeriodDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayPeriodPayload>
          }
          update: {
            args: Prisma.PayPeriodUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayPeriodPayload>
          }
          deleteMany: {
            args: Prisma.PayPeriodDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PayPeriodUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PayPeriodUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayPeriodPayload>[]
          }
          upsert: {
            args: Prisma.PayPeriodUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayPeriodPayload>
          }
          aggregate: {
            args: Prisma.PayPeriodAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayPeriod>
          }
          groupBy: {
            args: Prisma.PayPeriodGroupByArgs<ExtArgs>
            result: $Utils.Optional<PayPeriodGroupByOutputType>[]
          }
          count: {
            args: Prisma.PayPeriodCountArgs<ExtArgs>
            result: $Utils.Optional<PayPeriodCountAggregateOutputType> | number
          }
        }
      }
      Amendment: {
        payload: Prisma.$AmendmentPayload<ExtArgs>
        fields: Prisma.AmendmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AmendmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmendmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AmendmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmendmentPayload>
          }
          findFirst: {
            args: Prisma.AmendmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmendmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AmendmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmendmentPayload>
          }
          findMany: {
            args: Prisma.AmendmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmendmentPayload>[]
          }
          create: {
            args: Prisma.AmendmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmendmentPayload>
          }
          createMany: {
            args: Prisma.AmendmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AmendmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmendmentPayload>[]
          }
          delete: {
            args: Prisma.AmendmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmendmentPayload>
          }
          update: {
            args: Prisma.AmendmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmendmentPayload>
          }
          deleteMany: {
            args: Prisma.AmendmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AmendmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AmendmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmendmentPayload>[]
          }
          upsert: {
            args: Prisma.AmendmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmendmentPayload>
          }
          aggregate: {
            args: Prisma.AmendmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAmendment>
          }
          groupBy: {
            args: Prisma.AmendmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<AmendmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.AmendmentCountArgs<ExtArgs>
            result: $Utils.Optional<AmendmentCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    employee?: EmployeeOmit
    contract?: ContractOmit
    availabilityInterval?: AvailabilityIntervalOmit
    timeRecord?: TimeRecordOmit
    shift?: ShiftOmit
    dayLock?: DayLockOmit
    payPeriod?: PayPeriodOmit
    amendment?: AmendmentOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type EmployeeCountOutputType
   */

  export type EmployeeCountOutputType = {
    contracts: number
    timeRecords: number
    shifts: number
  }

  export type EmployeeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contracts?: boolean | EmployeeCountOutputTypeCountContractsArgs
    timeRecords?: boolean | EmployeeCountOutputTypeCountTimeRecordsArgs
    shifts?: boolean | EmployeeCountOutputTypeCountShiftsArgs
  }

  // Custom InputTypes
  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeCountOutputType
     */
    select?: EmployeeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountContractsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContractWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountTimeRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TimeRecordWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountShiftsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShiftWhereInput
  }


  /**
   * Count Type ContractCountOutputType
   */

  export type ContractCountOutputType = {
    availability: number
    amendments: number
  }

  export type ContractCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    availability?: boolean | ContractCountOutputTypeCountAvailabilityArgs
    amendments?: boolean | ContractCountOutputTypeCountAmendmentsArgs
  }

  // Custom InputTypes
  /**
   * ContractCountOutputType without action
   */
  export type ContractCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractCountOutputType
     */
    select?: ContractCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ContractCountOutputType without action
   */
  export type ContractCountOutputTypeCountAvailabilityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AvailabilityIntervalWhereInput
  }

  /**
   * ContractCountOutputType without action
   */
  export type ContractCountOutputTypeCountAmendmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AmendmentWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Employee
   */

  export type AggregateEmployee = {
    _count: EmployeeCountAggregateOutputType | null
    _avg: EmployeeAvgAggregateOutputType | null
    _sum: EmployeeSumAggregateOutputType | null
    _min: EmployeeMinAggregateOutputType | null
    _max: EmployeeMaxAggregateOutputType | null
  }

  export type EmployeeAvgAggregateOutputType = {
    matricule: number | null
  }

  export type EmployeeSumAggregateOutputType = {
    matricule: number | null
  }

  export type EmployeeMinAggregateOutputType = {
    id: string | null
    lastName: string | null
    firstName: string | null
    matricule: number | null
    dateOfBirth: Date | null
    sex: $Enums.Sex | null
    nationality: string | null
    address: string | null
    address2: string | null
    postalCode: string | null
    city: string | null
    iban: string | null
    bic: string | null
    socialSecurityNumber: string | null
    emergencyContactName: string | null
    emergencyContactPhone: string | null
    transportMeans: string | null
    photoUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmployeeMaxAggregateOutputType = {
    id: string | null
    lastName: string | null
    firstName: string | null
    matricule: number | null
    dateOfBirth: Date | null
    sex: $Enums.Sex | null
    nationality: string | null
    address: string | null
    address2: string | null
    postalCode: string | null
    city: string | null
    iban: string | null
    bic: string | null
    socialSecurityNumber: string | null
    emergencyContactName: string | null
    emergencyContactPhone: string | null
    transportMeans: string | null
    photoUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmployeeCountAggregateOutputType = {
    id: number
    lastName: number
    firstName: number
    matricule: number
    dateOfBirth: number
    sex: number
    nationality: number
    address: number
    address2: number
    postalCode: number
    city: number
    iban: number
    bic: number
    socialSecurityNumber: number
    emergencyContactName: number
    emergencyContactPhone: number
    transportMeans: number
    photoUrl: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EmployeeAvgAggregateInputType = {
    matricule?: true
  }

  export type EmployeeSumAggregateInputType = {
    matricule?: true
  }

  export type EmployeeMinAggregateInputType = {
    id?: true
    lastName?: true
    firstName?: true
    matricule?: true
    dateOfBirth?: true
    sex?: true
    nationality?: true
    address?: true
    address2?: true
    postalCode?: true
    city?: true
    iban?: true
    bic?: true
    socialSecurityNumber?: true
    emergencyContactName?: true
    emergencyContactPhone?: true
    transportMeans?: true
    photoUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmployeeMaxAggregateInputType = {
    id?: true
    lastName?: true
    firstName?: true
    matricule?: true
    dateOfBirth?: true
    sex?: true
    nationality?: true
    address?: true
    address2?: true
    postalCode?: true
    city?: true
    iban?: true
    bic?: true
    socialSecurityNumber?: true
    emergencyContactName?: true
    emergencyContactPhone?: true
    transportMeans?: true
    photoUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmployeeCountAggregateInputType = {
    id?: true
    lastName?: true
    firstName?: true
    matricule?: true
    dateOfBirth?: true
    sex?: true
    nationality?: true
    address?: true
    address2?: true
    postalCode?: true
    city?: true
    iban?: true
    bic?: true
    socialSecurityNumber?: true
    emergencyContactName?: true
    emergencyContactPhone?: true
    transportMeans?: true
    photoUrl?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EmployeeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Employee to aggregate.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Employees
    **/
    _count?: true | EmployeeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmployeeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmployeeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmployeeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmployeeMaxAggregateInputType
  }

  export type GetEmployeeAggregateType<T extends EmployeeAggregateArgs> = {
        [P in keyof T & keyof AggregateEmployee]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmployee[P]>
      : GetScalarType<T[P], AggregateEmployee[P]>
  }




  export type EmployeeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeWhereInput
    orderBy?: EmployeeOrderByWithAggregationInput | EmployeeOrderByWithAggregationInput[]
    by: EmployeeScalarFieldEnum[] | EmployeeScalarFieldEnum
    having?: EmployeeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmployeeCountAggregateInputType | true
    _avg?: EmployeeAvgAggregateInputType
    _sum?: EmployeeSumAggregateInputType
    _min?: EmployeeMinAggregateInputType
    _max?: EmployeeMaxAggregateInputType
  }

  export type EmployeeGroupByOutputType = {
    id: string
    lastName: string
    firstName: string
    matricule: number | null
    dateOfBirth: Date | null
    sex: $Enums.Sex | null
    nationality: string | null
    address: string | null
    address2: string | null
    postalCode: string | null
    city: string | null
    iban: string | null
    bic: string | null
    socialSecurityNumber: string | null
    emergencyContactName: string | null
    emergencyContactPhone: string | null
    transportMeans: string | null
    photoUrl: string | null
    createdAt: Date
    updatedAt: Date
    _count: EmployeeCountAggregateOutputType | null
    _avg: EmployeeAvgAggregateOutputType | null
    _sum: EmployeeSumAggregateOutputType | null
    _min: EmployeeMinAggregateOutputType | null
    _max: EmployeeMaxAggregateOutputType | null
  }

  type GetEmployeeGroupByPayload<T extends EmployeeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmployeeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmployeeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmployeeGroupByOutputType[P]>
            : GetScalarType<T[P], EmployeeGroupByOutputType[P]>
        }
      >
    >


  export type EmployeeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lastName?: boolean
    firstName?: boolean
    matricule?: boolean
    dateOfBirth?: boolean
    sex?: boolean
    nationality?: boolean
    address?: boolean
    address2?: boolean
    postalCode?: boolean
    city?: boolean
    iban?: boolean
    bic?: boolean
    socialSecurityNumber?: boolean
    emergencyContactName?: boolean
    emergencyContactPhone?: boolean
    transportMeans?: boolean
    photoUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    contracts?: boolean | Employee$contractsArgs<ExtArgs>
    timeRecords?: boolean | Employee$timeRecordsArgs<ExtArgs>
    shifts?: boolean | Employee$shiftsArgs<ExtArgs>
    _count?: boolean | EmployeeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employee"]>

  export type EmployeeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lastName?: boolean
    firstName?: boolean
    matricule?: boolean
    dateOfBirth?: boolean
    sex?: boolean
    nationality?: boolean
    address?: boolean
    address2?: boolean
    postalCode?: boolean
    city?: boolean
    iban?: boolean
    bic?: boolean
    socialSecurityNumber?: boolean
    emergencyContactName?: boolean
    emergencyContactPhone?: boolean
    transportMeans?: boolean
    photoUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["employee"]>

  export type EmployeeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lastName?: boolean
    firstName?: boolean
    matricule?: boolean
    dateOfBirth?: boolean
    sex?: boolean
    nationality?: boolean
    address?: boolean
    address2?: boolean
    postalCode?: boolean
    city?: boolean
    iban?: boolean
    bic?: boolean
    socialSecurityNumber?: boolean
    emergencyContactName?: boolean
    emergencyContactPhone?: boolean
    transportMeans?: boolean
    photoUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["employee"]>

  export type EmployeeSelectScalar = {
    id?: boolean
    lastName?: boolean
    firstName?: boolean
    matricule?: boolean
    dateOfBirth?: boolean
    sex?: boolean
    nationality?: boolean
    address?: boolean
    address2?: boolean
    postalCode?: boolean
    city?: boolean
    iban?: boolean
    bic?: boolean
    socialSecurityNumber?: boolean
    emergencyContactName?: boolean
    emergencyContactPhone?: boolean
    transportMeans?: boolean
    photoUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EmployeeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "lastName" | "firstName" | "matricule" | "dateOfBirth" | "sex" | "nationality" | "address" | "address2" | "postalCode" | "city" | "iban" | "bic" | "socialSecurityNumber" | "emergencyContactName" | "emergencyContactPhone" | "transportMeans" | "photoUrl" | "createdAt" | "updatedAt", ExtArgs["result"]["employee"]>
  export type EmployeeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contracts?: boolean | Employee$contractsArgs<ExtArgs>
    timeRecords?: boolean | Employee$timeRecordsArgs<ExtArgs>
    shifts?: boolean | Employee$shiftsArgs<ExtArgs>
    _count?: boolean | EmployeeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EmployeeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type EmployeeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $EmployeePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Employee"
    objects: {
      contracts: Prisma.$ContractPayload<ExtArgs>[]
      timeRecords: Prisma.$TimeRecordPayload<ExtArgs>[]
      shifts: Prisma.$ShiftPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      lastName: string
      firstName: string
      matricule: number | null
      dateOfBirth: Date | null
      sex: $Enums.Sex | null
      nationality: string | null
      address: string | null
      address2: string | null
      postalCode: string | null
      city: string | null
      iban: string | null
      bic: string | null
      socialSecurityNumber: string | null
      emergencyContactName: string | null
      emergencyContactPhone: string | null
      transportMeans: string | null
      photoUrl: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["employee"]>
    composites: {}
  }

  type EmployeeGetPayload<S extends boolean | null | undefined | EmployeeDefaultArgs> = $Result.GetResult<Prisma.$EmployeePayload, S>

  type EmployeeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmployeeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmployeeCountAggregateInputType | true
    }

  export interface EmployeeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Employee'], meta: { name: 'Employee' } }
    /**
     * Find zero or one Employee that matches the filter.
     * @param {EmployeeFindUniqueArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmployeeFindUniqueArgs>(args: SelectSubset<T, EmployeeFindUniqueArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Employee that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmployeeFindUniqueOrThrowArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmployeeFindUniqueOrThrowArgs>(args: SelectSubset<T, EmployeeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Employee that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeFindFirstArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmployeeFindFirstArgs>(args?: SelectSubset<T, EmployeeFindFirstArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Employee that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeFindFirstOrThrowArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmployeeFindFirstOrThrowArgs>(args?: SelectSubset<T, EmployeeFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Employees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Employees
     * const employees = await prisma.employee.findMany()
     * 
     * // Get first 10 Employees
     * const employees = await prisma.employee.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const employeeWithIdOnly = await prisma.employee.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmployeeFindManyArgs>(args?: SelectSubset<T, EmployeeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Employee.
     * @param {EmployeeCreateArgs} args - Arguments to create a Employee.
     * @example
     * // Create one Employee
     * const Employee = await prisma.employee.create({
     *   data: {
     *     // ... data to create a Employee
     *   }
     * })
     * 
     */
    create<T extends EmployeeCreateArgs>(args: SelectSubset<T, EmployeeCreateArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Employees.
     * @param {EmployeeCreateManyArgs} args - Arguments to create many Employees.
     * @example
     * // Create many Employees
     * const employee = await prisma.employee.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmployeeCreateManyArgs>(args?: SelectSubset<T, EmployeeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Employees and returns the data saved in the database.
     * @param {EmployeeCreateManyAndReturnArgs} args - Arguments to create many Employees.
     * @example
     * // Create many Employees
     * const employee = await prisma.employee.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Employees and only return the `id`
     * const employeeWithIdOnly = await prisma.employee.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmployeeCreateManyAndReturnArgs>(args?: SelectSubset<T, EmployeeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Employee.
     * @param {EmployeeDeleteArgs} args - Arguments to delete one Employee.
     * @example
     * // Delete one Employee
     * const Employee = await prisma.employee.delete({
     *   where: {
     *     // ... filter to delete one Employee
     *   }
     * })
     * 
     */
    delete<T extends EmployeeDeleteArgs>(args: SelectSubset<T, EmployeeDeleteArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Employee.
     * @param {EmployeeUpdateArgs} args - Arguments to update one Employee.
     * @example
     * // Update one Employee
     * const employee = await prisma.employee.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmployeeUpdateArgs>(args: SelectSubset<T, EmployeeUpdateArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Employees.
     * @param {EmployeeDeleteManyArgs} args - Arguments to filter Employees to delete.
     * @example
     * // Delete a few Employees
     * const { count } = await prisma.employee.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmployeeDeleteManyArgs>(args?: SelectSubset<T, EmployeeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Employees
     * const employee = await prisma.employee.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmployeeUpdateManyArgs>(args: SelectSubset<T, EmployeeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Employees and returns the data updated in the database.
     * @param {EmployeeUpdateManyAndReturnArgs} args - Arguments to update many Employees.
     * @example
     * // Update many Employees
     * const employee = await prisma.employee.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Employees and only return the `id`
     * const employeeWithIdOnly = await prisma.employee.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EmployeeUpdateManyAndReturnArgs>(args: SelectSubset<T, EmployeeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Employee.
     * @param {EmployeeUpsertArgs} args - Arguments to update or create a Employee.
     * @example
     * // Update or create a Employee
     * const employee = await prisma.employee.upsert({
     *   create: {
     *     // ... data to create a Employee
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Employee we want to update
     *   }
     * })
     */
    upsert<T extends EmployeeUpsertArgs>(args: SelectSubset<T, EmployeeUpsertArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeCountArgs} args - Arguments to filter Employees to count.
     * @example
     * // Count the number of Employees
     * const count = await prisma.employee.count({
     *   where: {
     *     // ... the filter for the Employees we want to count
     *   }
     * })
    **/
    count<T extends EmployeeCountArgs>(
      args?: Subset<T, EmployeeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmployeeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Employee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmployeeAggregateArgs>(args: Subset<T, EmployeeAggregateArgs>): Prisma.PrismaPromise<GetEmployeeAggregateType<T>>

    /**
     * Group by Employee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmployeeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmployeeGroupByArgs['orderBy'] }
        : { orderBy?: EmployeeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmployeeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmployeeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Employee model
   */
  readonly fields: EmployeeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Employee.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmployeeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    contracts<T extends Employee$contractsArgs<ExtArgs> = {}>(args?: Subset<T, Employee$contractsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    timeRecords<T extends Employee$timeRecordsArgs<ExtArgs> = {}>(args?: Subset<T, Employee$timeRecordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimeRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    shifts<T extends Employee$shiftsArgs<ExtArgs> = {}>(args?: Subset<T, Employee$shiftsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Employee model
   */ 
  interface EmployeeFieldRefs {
    readonly id: FieldRef<"Employee", 'String'>
    readonly lastName: FieldRef<"Employee", 'String'>
    readonly firstName: FieldRef<"Employee", 'String'>
    readonly matricule: FieldRef<"Employee", 'Int'>
    readonly dateOfBirth: FieldRef<"Employee", 'DateTime'>
    readonly sex: FieldRef<"Employee", 'Sex'>
    readonly nationality: FieldRef<"Employee", 'String'>
    readonly address: FieldRef<"Employee", 'String'>
    readonly address2: FieldRef<"Employee", 'String'>
    readonly postalCode: FieldRef<"Employee", 'String'>
    readonly city: FieldRef<"Employee", 'String'>
    readonly iban: FieldRef<"Employee", 'String'>
    readonly bic: FieldRef<"Employee", 'String'>
    readonly socialSecurityNumber: FieldRef<"Employee", 'String'>
    readonly emergencyContactName: FieldRef<"Employee", 'String'>
    readonly emergencyContactPhone: FieldRef<"Employee", 'String'>
    readonly transportMeans: FieldRef<"Employee", 'String'>
    readonly photoUrl: FieldRef<"Employee", 'String'>
    readonly createdAt: FieldRef<"Employee", 'DateTime'>
    readonly updatedAt: FieldRef<"Employee", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Employee findUnique
   */
  export type EmployeeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee findUniqueOrThrow
   */
  export type EmployeeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee findFirst
   */
  export type EmployeeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Employees.
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Employees.
     */
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Employee findFirstOrThrow
   */
  export type EmployeeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Employees.
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Employees.
     */
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Employee findMany
   */
  export type EmployeeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employees to fetch.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Employees.
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Employee create
   */
  export type EmployeeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * The data needed to create a Employee.
     */
    data: XOR<EmployeeCreateInput, EmployeeUncheckedCreateInput>
  }

  /**
   * Employee createMany
   */
  export type EmployeeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Employees.
     */
    data: EmployeeCreateManyInput | EmployeeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Employee createManyAndReturn
   */
  export type EmployeeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * The data used to create many Employees.
     */
    data: EmployeeCreateManyInput | EmployeeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Employee update
   */
  export type EmployeeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * The data needed to update a Employee.
     */
    data: XOR<EmployeeUpdateInput, EmployeeUncheckedUpdateInput>
    /**
     * Choose, which Employee to update.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee updateMany
   */
  export type EmployeeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Employees.
     */
    data: XOR<EmployeeUpdateManyMutationInput, EmployeeUncheckedUpdateManyInput>
    /**
     * Filter which Employees to update
     */
    where?: EmployeeWhereInput
    /**
     * Limit how many Employees to update.
     */
    limit?: number
  }

  /**
   * Employee updateManyAndReturn
   */
  export type EmployeeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * The data used to update Employees.
     */
    data: XOR<EmployeeUpdateManyMutationInput, EmployeeUncheckedUpdateManyInput>
    /**
     * Filter which Employees to update
     */
    where?: EmployeeWhereInput
    /**
     * Limit how many Employees to update.
     */
    limit?: number
  }

  /**
   * Employee upsert
   */
  export type EmployeeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * The filter to search for the Employee to update in case it exists.
     */
    where: EmployeeWhereUniqueInput
    /**
     * In case the Employee found by the `where` argument doesn't exist, create a new Employee with this data.
     */
    create: XOR<EmployeeCreateInput, EmployeeUncheckedCreateInput>
    /**
     * In case the Employee was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmployeeUpdateInput, EmployeeUncheckedUpdateInput>
  }

  /**
   * Employee delete
   */
  export type EmployeeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter which Employee to delete.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee deleteMany
   */
  export type EmployeeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Employees to delete
     */
    where?: EmployeeWhereInput
    /**
     * Limit how many Employees to delete.
     */
    limit?: number
  }

  /**
   * Employee.contracts
   */
  export type Employee$contractsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contract
     */
    omit?: ContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    where?: ContractWhereInput
    orderBy?: ContractOrderByWithRelationInput | ContractOrderByWithRelationInput[]
    cursor?: ContractWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContractScalarFieldEnum | ContractScalarFieldEnum[]
  }

  /**
   * Employee.timeRecords
   */
  export type Employee$timeRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeRecord
     */
    select?: TimeRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeRecord
     */
    omit?: TimeRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeRecordInclude<ExtArgs> | null
    where?: TimeRecordWhereInput
    orderBy?: TimeRecordOrderByWithRelationInput | TimeRecordOrderByWithRelationInput[]
    cursor?: TimeRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TimeRecordScalarFieldEnum | TimeRecordScalarFieldEnum[]
  }

  /**
   * Employee.shifts
   */
  export type Employee$shiftsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shift
     */
    omit?: ShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
    where?: ShiftWhereInput
    orderBy?: ShiftOrderByWithRelationInput | ShiftOrderByWithRelationInput[]
    cursor?: ShiftWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShiftScalarFieldEnum | ShiftScalarFieldEnum[]
  }

  /**
   * Employee without action
   */
  export type EmployeeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
  }


  /**
   * Model Contract
   */

  export type AggregateContract = {
    _count: ContractCountAggregateOutputType | null
    _avg: ContractAvgAggregateOutputType | null
    _sum: ContractSumAggregateOutputType | null
    _min: ContractMinAggregateOutputType | null
    _max: ContractMaxAggregateOutputType | null
  }

  export type ContractAvgAggregateOutputType = {
    hoursPerWeek: number | null
  }

  export type ContractSumAggregateOutputType = {
    hoursPerWeek: number | null
  }

  export type ContractMinAggregateOutputType = {
    id: string | null
    contractType: string | null
    role: string | null
    hoursPerWeek: number | null
    status: $Enums.ContractStatus | null
    resignationDate: Date | null
    endDate: Date | null
    employeeId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContractMaxAggregateOutputType = {
    id: string | null
    contractType: string | null
    role: string | null
    hoursPerWeek: number | null
    status: $Enums.ContractStatus | null
    resignationDate: Date | null
    endDate: Date | null
    employeeId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContractCountAggregateOutputType = {
    id: number
    contractType: number
    role: number
    hoursPerWeek: number
    status: number
    resignationDate: number
    endDate: number
    employeeId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ContractAvgAggregateInputType = {
    hoursPerWeek?: true
  }

  export type ContractSumAggregateInputType = {
    hoursPerWeek?: true
  }

  export type ContractMinAggregateInputType = {
    id?: true
    contractType?: true
    role?: true
    hoursPerWeek?: true
    status?: true
    resignationDate?: true
    endDate?: true
    employeeId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContractMaxAggregateInputType = {
    id?: true
    contractType?: true
    role?: true
    hoursPerWeek?: true
    status?: true
    resignationDate?: true
    endDate?: true
    employeeId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContractCountAggregateInputType = {
    id?: true
    contractType?: true
    role?: true
    hoursPerWeek?: true
    status?: true
    resignationDate?: true
    endDate?: true
    employeeId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ContractAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contract to aggregate.
     */
    where?: ContractWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contracts to fetch.
     */
    orderBy?: ContractOrderByWithRelationInput | ContractOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContractWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contracts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contracts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Contracts
    **/
    _count?: true | ContractCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContractAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContractSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContractMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContractMaxAggregateInputType
  }

  export type GetContractAggregateType<T extends ContractAggregateArgs> = {
        [P in keyof T & keyof AggregateContract]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContract[P]>
      : GetScalarType<T[P], AggregateContract[P]>
  }




  export type ContractGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContractWhereInput
    orderBy?: ContractOrderByWithAggregationInput | ContractOrderByWithAggregationInput[]
    by: ContractScalarFieldEnum[] | ContractScalarFieldEnum
    having?: ContractScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContractCountAggregateInputType | true
    _avg?: ContractAvgAggregateInputType
    _sum?: ContractSumAggregateInputType
    _min?: ContractMinAggregateInputType
    _max?: ContractMaxAggregateInputType
  }

  export type ContractGroupByOutputType = {
    id: string
    contractType: string | null
    role: string | null
    hoursPerWeek: number | null
    status: $Enums.ContractStatus | null
    resignationDate: Date | null
    endDate: Date | null
    employeeId: string
    createdAt: Date
    updatedAt: Date
    _count: ContractCountAggregateOutputType | null
    _avg: ContractAvgAggregateOutputType | null
    _sum: ContractSumAggregateOutputType | null
    _min: ContractMinAggregateOutputType | null
    _max: ContractMaxAggregateOutputType | null
  }

  type GetContractGroupByPayload<T extends ContractGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContractGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContractGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContractGroupByOutputType[P]>
            : GetScalarType<T[P], ContractGroupByOutputType[P]>
        }
      >
    >


  export type ContractSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contractType?: boolean
    role?: boolean
    hoursPerWeek?: boolean
    status?: boolean
    resignationDate?: boolean
    endDate?: boolean
    employeeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    availability?: boolean | Contract$availabilityArgs<ExtArgs>
    amendments?: boolean | Contract$amendmentsArgs<ExtArgs>
    _count?: boolean | ContractCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contract"]>

  export type ContractSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contractType?: boolean
    role?: boolean
    hoursPerWeek?: boolean
    status?: boolean
    resignationDate?: boolean
    endDate?: boolean
    employeeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contract"]>

  export type ContractSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contractType?: boolean
    role?: boolean
    hoursPerWeek?: boolean
    status?: boolean
    resignationDate?: boolean
    endDate?: boolean
    employeeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contract"]>

  export type ContractSelectScalar = {
    id?: boolean
    contractType?: boolean
    role?: boolean
    hoursPerWeek?: boolean
    status?: boolean
    resignationDate?: boolean
    endDate?: boolean
    employeeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ContractOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "contractType" | "role" | "hoursPerWeek" | "status" | "resignationDate" | "endDate" | "employeeId" | "createdAt" | "updatedAt", ExtArgs["result"]["contract"]>
  export type ContractInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    availability?: boolean | Contract$availabilityArgs<ExtArgs>
    amendments?: boolean | Contract$amendmentsArgs<ExtArgs>
    _count?: boolean | ContractCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ContractIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }
  export type ContractIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }

  export type $ContractPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Contract"
    objects: {
      employee: Prisma.$EmployeePayload<ExtArgs>
      availability: Prisma.$AvailabilityIntervalPayload<ExtArgs>[]
      amendments: Prisma.$AmendmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      contractType: string | null
      role: string | null
      hoursPerWeek: number | null
      status: $Enums.ContractStatus | null
      resignationDate: Date | null
      endDate: Date | null
      employeeId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["contract"]>
    composites: {}
  }

  type ContractGetPayload<S extends boolean | null | undefined | ContractDefaultArgs> = $Result.GetResult<Prisma.$ContractPayload, S>

  type ContractCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContractFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContractCountAggregateInputType | true
    }

  export interface ContractDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Contract'], meta: { name: 'Contract' } }
    /**
     * Find zero or one Contract that matches the filter.
     * @param {ContractFindUniqueArgs} args - Arguments to find a Contract
     * @example
     * // Get one Contract
     * const contract = await prisma.contract.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContractFindUniqueArgs>(args: SelectSubset<T, ContractFindUniqueArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Contract that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContractFindUniqueOrThrowArgs} args - Arguments to find a Contract
     * @example
     * // Get one Contract
     * const contract = await prisma.contract.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContractFindUniqueOrThrowArgs>(args: SelectSubset<T, ContractFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Contract that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractFindFirstArgs} args - Arguments to find a Contract
     * @example
     * // Get one Contract
     * const contract = await prisma.contract.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContractFindFirstArgs>(args?: SelectSubset<T, ContractFindFirstArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Contract that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractFindFirstOrThrowArgs} args - Arguments to find a Contract
     * @example
     * // Get one Contract
     * const contract = await prisma.contract.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContractFindFirstOrThrowArgs>(args?: SelectSubset<T, ContractFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Contracts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contracts
     * const contracts = await prisma.contract.findMany()
     * 
     * // Get first 10 Contracts
     * const contracts = await prisma.contract.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contractWithIdOnly = await prisma.contract.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContractFindManyArgs>(args?: SelectSubset<T, ContractFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Contract.
     * @param {ContractCreateArgs} args - Arguments to create a Contract.
     * @example
     * // Create one Contract
     * const Contract = await prisma.contract.create({
     *   data: {
     *     // ... data to create a Contract
     *   }
     * })
     * 
     */
    create<T extends ContractCreateArgs>(args: SelectSubset<T, ContractCreateArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Contracts.
     * @param {ContractCreateManyArgs} args - Arguments to create many Contracts.
     * @example
     * // Create many Contracts
     * const contract = await prisma.contract.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContractCreateManyArgs>(args?: SelectSubset<T, ContractCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Contracts and returns the data saved in the database.
     * @param {ContractCreateManyAndReturnArgs} args - Arguments to create many Contracts.
     * @example
     * // Create many Contracts
     * const contract = await prisma.contract.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Contracts and only return the `id`
     * const contractWithIdOnly = await prisma.contract.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContractCreateManyAndReturnArgs>(args?: SelectSubset<T, ContractCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Contract.
     * @param {ContractDeleteArgs} args - Arguments to delete one Contract.
     * @example
     * // Delete one Contract
     * const Contract = await prisma.contract.delete({
     *   where: {
     *     // ... filter to delete one Contract
     *   }
     * })
     * 
     */
    delete<T extends ContractDeleteArgs>(args: SelectSubset<T, ContractDeleteArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Contract.
     * @param {ContractUpdateArgs} args - Arguments to update one Contract.
     * @example
     * // Update one Contract
     * const contract = await prisma.contract.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContractUpdateArgs>(args: SelectSubset<T, ContractUpdateArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Contracts.
     * @param {ContractDeleteManyArgs} args - Arguments to filter Contracts to delete.
     * @example
     * // Delete a few Contracts
     * const { count } = await prisma.contract.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContractDeleteManyArgs>(args?: SelectSubset<T, ContractDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contracts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contracts
     * const contract = await prisma.contract.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContractUpdateManyArgs>(args: SelectSubset<T, ContractUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contracts and returns the data updated in the database.
     * @param {ContractUpdateManyAndReturnArgs} args - Arguments to update many Contracts.
     * @example
     * // Update many Contracts
     * const contract = await prisma.contract.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Contracts and only return the `id`
     * const contractWithIdOnly = await prisma.contract.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ContractUpdateManyAndReturnArgs>(args: SelectSubset<T, ContractUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Contract.
     * @param {ContractUpsertArgs} args - Arguments to update or create a Contract.
     * @example
     * // Update or create a Contract
     * const contract = await prisma.contract.upsert({
     *   create: {
     *     // ... data to create a Contract
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Contract we want to update
     *   }
     * })
     */
    upsert<T extends ContractUpsertArgs>(args: SelectSubset<T, ContractUpsertArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Contracts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractCountArgs} args - Arguments to filter Contracts to count.
     * @example
     * // Count the number of Contracts
     * const count = await prisma.contract.count({
     *   where: {
     *     // ... the filter for the Contracts we want to count
     *   }
     * })
    **/
    count<T extends ContractCountArgs>(
      args?: Subset<T, ContractCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContractCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Contract.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContractAggregateArgs>(args: Subset<T, ContractAggregateArgs>): Prisma.PrismaPromise<GetContractAggregateType<T>>

    /**
     * Group by Contract.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContractGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContractGroupByArgs['orderBy'] }
        : { orderBy?: ContractGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContractGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContractGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Contract model
   */
  readonly fields: ContractFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Contract.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContractClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee<T extends EmployeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeDefaultArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    availability<T extends Contract$availabilityArgs<ExtArgs> = {}>(args?: Subset<T, Contract$availabilityArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AvailabilityIntervalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    amendments<T extends Contract$amendmentsArgs<ExtArgs> = {}>(args?: Subset<T, Contract$amendmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AmendmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Contract model
   */ 
  interface ContractFieldRefs {
    readonly id: FieldRef<"Contract", 'String'>
    readonly contractType: FieldRef<"Contract", 'String'>
    readonly role: FieldRef<"Contract", 'String'>
    readonly hoursPerWeek: FieldRef<"Contract", 'Int'>
    readonly status: FieldRef<"Contract", 'ContractStatus'>
    readonly resignationDate: FieldRef<"Contract", 'DateTime'>
    readonly endDate: FieldRef<"Contract", 'DateTime'>
    readonly employeeId: FieldRef<"Contract", 'String'>
    readonly createdAt: FieldRef<"Contract", 'DateTime'>
    readonly updatedAt: FieldRef<"Contract", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Contract findUnique
   */
  export type ContractFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contract
     */
    omit?: ContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    /**
     * Filter, which Contract to fetch.
     */
    where: ContractWhereUniqueInput
  }

  /**
   * Contract findUniqueOrThrow
   */
  export type ContractFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contract
     */
    omit?: ContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    /**
     * Filter, which Contract to fetch.
     */
    where: ContractWhereUniqueInput
  }

  /**
   * Contract findFirst
   */
  export type ContractFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contract
     */
    omit?: ContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    /**
     * Filter, which Contract to fetch.
     */
    where?: ContractWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contracts to fetch.
     */
    orderBy?: ContractOrderByWithRelationInput | ContractOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contracts.
     */
    cursor?: ContractWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contracts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contracts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contracts.
     */
    distinct?: ContractScalarFieldEnum | ContractScalarFieldEnum[]
  }

  /**
   * Contract findFirstOrThrow
   */
  export type ContractFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contract
     */
    omit?: ContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    /**
     * Filter, which Contract to fetch.
     */
    where?: ContractWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contracts to fetch.
     */
    orderBy?: ContractOrderByWithRelationInput | ContractOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contracts.
     */
    cursor?: ContractWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contracts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contracts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contracts.
     */
    distinct?: ContractScalarFieldEnum | ContractScalarFieldEnum[]
  }

  /**
   * Contract findMany
   */
  export type ContractFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contract
     */
    omit?: ContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    /**
     * Filter, which Contracts to fetch.
     */
    where?: ContractWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contracts to fetch.
     */
    orderBy?: ContractOrderByWithRelationInput | ContractOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Contracts.
     */
    cursor?: ContractWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contracts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contracts.
     */
    skip?: number
    distinct?: ContractScalarFieldEnum | ContractScalarFieldEnum[]
  }

  /**
   * Contract create
   */
  export type ContractCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contract
     */
    omit?: ContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    /**
     * The data needed to create a Contract.
     */
    data: XOR<ContractCreateInput, ContractUncheckedCreateInput>
  }

  /**
   * Contract createMany
   */
  export type ContractCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Contracts.
     */
    data: ContractCreateManyInput | ContractCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Contract createManyAndReturn
   */
  export type ContractCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Contract
     */
    omit?: ContractOmit<ExtArgs> | null
    /**
     * The data used to create many Contracts.
     */
    data: ContractCreateManyInput | ContractCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Contract update
   */
  export type ContractUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contract
     */
    omit?: ContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    /**
     * The data needed to update a Contract.
     */
    data: XOR<ContractUpdateInput, ContractUncheckedUpdateInput>
    /**
     * Choose, which Contract to update.
     */
    where: ContractWhereUniqueInput
  }

  /**
   * Contract updateMany
   */
  export type ContractUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Contracts.
     */
    data: XOR<ContractUpdateManyMutationInput, ContractUncheckedUpdateManyInput>
    /**
     * Filter which Contracts to update
     */
    where?: ContractWhereInput
    /**
     * Limit how many Contracts to update.
     */
    limit?: number
  }

  /**
   * Contract updateManyAndReturn
   */
  export type ContractUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Contract
     */
    omit?: ContractOmit<ExtArgs> | null
    /**
     * The data used to update Contracts.
     */
    data: XOR<ContractUpdateManyMutationInput, ContractUncheckedUpdateManyInput>
    /**
     * Filter which Contracts to update
     */
    where?: ContractWhereInput
    /**
     * Limit how many Contracts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Contract upsert
   */
  export type ContractUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contract
     */
    omit?: ContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    /**
     * The filter to search for the Contract to update in case it exists.
     */
    where: ContractWhereUniqueInput
    /**
     * In case the Contract found by the `where` argument doesn't exist, create a new Contract with this data.
     */
    create: XOR<ContractCreateInput, ContractUncheckedCreateInput>
    /**
     * In case the Contract was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContractUpdateInput, ContractUncheckedUpdateInput>
  }

  /**
   * Contract delete
   */
  export type ContractDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contract
     */
    omit?: ContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    /**
     * Filter which Contract to delete.
     */
    where: ContractWhereUniqueInput
  }

  /**
   * Contract deleteMany
   */
  export type ContractDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contracts to delete
     */
    where?: ContractWhereInput
    /**
     * Limit how many Contracts to delete.
     */
    limit?: number
  }

  /**
   * Contract.availability
   */
  export type Contract$availabilityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AvailabilityInterval
     */
    select?: AvailabilityIntervalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AvailabilityInterval
     */
    omit?: AvailabilityIntervalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvailabilityIntervalInclude<ExtArgs> | null
    where?: AvailabilityIntervalWhereInput
    orderBy?: AvailabilityIntervalOrderByWithRelationInput | AvailabilityIntervalOrderByWithRelationInput[]
    cursor?: AvailabilityIntervalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AvailabilityIntervalScalarFieldEnum | AvailabilityIntervalScalarFieldEnum[]
  }

  /**
   * Contract.amendments
   */
  export type Contract$amendmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amendment
     */
    select?: AmendmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Amendment
     */
    omit?: AmendmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmendmentInclude<ExtArgs> | null
    where?: AmendmentWhereInput
    orderBy?: AmendmentOrderByWithRelationInput | AmendmentOrderByWithRelationInput[]
    cursor?: AmendmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AmendmentScalarFieldEnum | AmendmentScalarFieldEnum[]
  }

  /**
   * Contract without action
   */
  export type ContractDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contract
     */
    omit?: ContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
  }


  /**
   * Model AvailabilityInterval
   */

  export type AggregateAvailabilityInterval = {
    _count: AvailabilityIntervalCountAggregateOutputType | null
    _min: AvailabilityIntervalMinAggregateOutputType | null
    _max: AvailabilityIntervalMaxAggregateOutputType | null
  }

  export type AvailabilityIntervalMinAggregateOutputType = {
    id: string | null
    day: $Enums.DayOfWeek | null
    allDay: boolean | null
    startTime: string | null
    endTime: string | null
    contractId: string | null
  }

  export type AvailabilityIntervalMaxAggregateOutputType = {
    id: string | null
    day: $Enums.DayOfWeek | null
    allDay: boolean | null
    startTime: string | null
    endTime: string | null
    contractId: string | null
  }

  export type AvailabilityIntervalCountAggregateOutputType = {
    id: number
    day: number
    allDay: number
    startTime: number
    endTime: number
    contractId: number
    _all: number
  }


  export type AvailabilityIntervalMinAggregateInputType = {
    id?: true
    day?: true
    allDay?: true
    startTime?: true
    endTime?: true
    contractId?: true
  }

  export type AvailabilityIntervalMaxAggregateInputType = {
    id?: true
    day?: true
    allDay?: true
    startTime?: true
    endTime?: true
    contractId?: true
  }

  export type AvailabilityIntervalCountAggregateInputType = {
    id?: true
    day?: true
    allDay?: true
    startTime?: true
    endTime?: true
    contractId?: true
    _all?: true
  }

  export type AvailabilityIntervalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AvailabilityInterval to aggregate.
     */
    where?: AvailabilityIntervalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AvailabilityIntervals to fetch.
     */
    orderBy?: AvailabilityIntervalOrderByWithRelationInput | AvailabilityIntervalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AvailabilityIntervalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AvailabilityIntervals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AvailabilityIntervals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AvailabilityIntervals
    **/
    _count?: true | AvailabilityIntervalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AvailabilityIntervalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AvailabilityIntervalMaxAggregateInputType
  }

  export type GetAvailabilityIntervalAggregateType<T extends AvailabilityIntervalAggregateArgs> = {
        [P in keyof T & keyof AggregateAvailabilityInterval]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAvailabilityInterval[P]>
      : GetScalarType<T[P], AggregateAvailabilityInterval[P]>
  }




  export type AvailabilityIntervalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AvailabilityIntervalWhereInput
    orderBy?: AvailabilityIntervalOrderByWithAggregationInput | AvailabilityIntervalOrderByWithAggregationInput[]
    by: AvailabilityIntervalScalarFieldEnum[] | AvailabilityIntervalScalarFieldEnum
    having?: AvailabilityIntervalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AvailabilityIntervalCountAggregateInputType | true
    _min?: AvailabilityIntervalMinAggregateInputType
    _max?: AvailabilityIntervalMaxAggregateInputType
  }

  export type AvailabilityIntervalGroupByOutputType = {
    id: string
    day: $Enums.DayOfWeek
    allDay: boolean
    startTime: string | null
    endTime: string | null
    contractId: string
    _count: AvailabilityIntervalCountAggregateOutputType | null
    _min: AvailabilityIntervalMinAggregateOutputType | null
    _max: AvailabilityIntervalMaxAggregateOutputType | null
  }

  type GetAvailabilityIntervalGroupByPayload<T extends AvailabilityIntervalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AvailabilityIntervalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AvailabilityIntervalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AvailabilityIntervalGroupByOutputType[P]>
            : GetScalarType<T[P], AvailabilityIntervalGroupByOutputType[P]>
        }
      >
    >


  export type AvailabilityIntervalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    day?: boolean
    allDay?: boolean
    startTime?: boolean
    endTime?: boolean
    contractId?: boolean
    contract?: boolean | ContractDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["availabilityInterval"]>

  export type AvailabilityIntervalSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    day?: boolean
    allDay?: boolean
    startTime?: boolean
    endTime?: boolean
    contractId?: boolean
    contract?: boolean | ContractDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["availabilityInterval"]>

  export type AvailabilityIntervalSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    day?: boolean
    allDay?: boolean
    startTime?: boolean
    endTime?: boolean
    contractId?: boolean
    contract?: boolean | ContractDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["availabilityInterval"]>

  export type AvailabilityIntervalSelectScalar = {
    id?: boolean
    day?: boolean
    allDay?: boolean
    startTime?: boolean
    endTime?: boolean
    contractId?: boolean
  }

  export type AvailabilityIntervalOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "day" | "allDay" | "startTime" | "endTime" | "contractId", ExtArgs["result"]["availabilityInterval"]>
  export type AvailabilityIntervalInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contract?: boolean | ContractDefaultArgs<ExtArgs>
  }
  export type AvailabilityIntervalIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contract?: boolean | ContractDefaultArgs<ExtArgs>
  }
  export type AvailabilityIntervalIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contract?: boolean | ContractDefaultArgs<ExtArgs>
  }

  export type $AvailabilityIntervalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AvailabilityInterval"
    objects: {
      contract: Prisma.$ContractPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      day: $Enums.DayOfWeek
      allDay: boolean
      startTime: string | null
      endTime: string | null
      contractId: string
    }, ExtArgs["result"]["availabilityInterval"]>
    composites: {}
  }

  type AvailabilityIntervalGetPayload<S extends boolean | null | undefined | AvailabilityIntervalDefaultArgs> = $Result.GetResult<Prisma.$AvailabilityIntervalPayload, S>

  type AvailabilityIntervalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AvailabilityIntervalFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AvailabilityIntervalCountAggregateInputType | true
    }

  export interface AvailabilityIntervalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AvailabilityInterval'], meta: { name: 'AvailabilityInterval' } }
    /**
     * Find zero or one AvailabilityInterval that matches the filter.
     * @param {AvailabilityIntervalFindUniqueArgs} args - Arguments to find a AvailabilityInterval
     * @example
     * // Get one AvailabilityInterval
     * const availabilityInterval = await prisma.availabilityInterval.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AvailabilityIntervalFindUniqueArgs>(args: SelectSubset<T, AvailabilityIntervalFindUniqueArgs<ExtArgs>>): Prisma__AvailabilityIntervalClient<$Result.GetResult<Prisma.$AvailabilityIntervalPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AvailabilityInterval that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AvailabilityIntervalFindUniqueOrThrowArgs} args - Arguments to find a AvailabilityInterval
     * @example
     * // Get one AvailabilityInterval
     * const availabilityInterval = await prisma.availabilityInterval.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AvailabilityIntervalFindUniqueOrThrowArgs>(args: SelectSubset<T, AvailabilityIntervalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AvailabilityIntervalClient<$Result.GetResult<Prisma.$AvailabilityIntervalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AvailabilityInterval that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvailabilityIntervalFindFirstArgs} args - Arguments to find a AvailabilityInterval
     * @example
     * // Get one AvailabilityInterval
     * const availabilityInterval = await prisma.availabilityInterval.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AvailabilityIntervalFindFirstArgs>(args?: SelectSubset<T, AvailabilityIntervalFindFirstArgs<ExtArgs>>): Prisma__AvailabilityIntervalClient<$Result.GetResult<Prisma.$AvailabilityIntervalPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AvailabilityInterval that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvailabilityIntervalFindFirstOrThrowArgs} args - Arguments to find a AvailabilityInterval
     * @example
     * // Get one AvailabilityInterval
     * const availabilityInterval = await prisma.availabilityInterval.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AvailabilityIntervalFindFirstOrThrowArgs>(args?: SelectSubset<T, AvailabilityIntervalFindFirstOrThrowArgs<ExtArgs>>): Prisma__AvailabilityIntervalClient<$Result.GetResult<Prisma.$AvailabilityIntervalPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AvailabilityIntervals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvailabilityIntervalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AvailabilityIntervals
     * const availabilityIntervals = await prisma.availabilityInterval.findMany()
     * 
     * // Get first 10 AvailabilityIntervals
     * const availabilityIntervals = await prisma.availabilityInterval.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const availabilityIntervalWithIdOnly = await prisma.availabilityInterval.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AvailabilityIntervalFindManyArgs>(args?: SelectSubset<T, AvailabilityIntervalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AvailabilityIntervalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AvailabilityInterval.
     * @param {AvailabilityIntervalCreateArgs} args - Arguments to create a AvailabilityInterval.
     * @example
     * // Create one AvailabilityInterval
     * const AvailabilityInterval = await prisma.availabilityInterval.create({
     *   data: {
     *     // ... data to create a AvailabilityInterval
     *   }
     * })
     * 
     */
    create<T extends AvailabilityIntervalCreateArgs>(args: SelectSubset<T, AvailabilityIntervalCreateArgs<ExtArgs>>): Prisma__AvailabilityIntervalClient<$Result.GetResult<Prisma.$AvailabilityIntervalPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AvailabilityIntervals.
     * @param {AvailabilityIntervalCreateManyArgs} args - Arguments to create many AvailabilityIntervals.
     * @example
     * // Create many AvailabilityIntervals
     * const availabilityInterval = await prisma.availabilityInterval.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AvailabilityIntervalCreateManyArgs>(args?: SelectSubset<T, AvailabilityIntervalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AvailabilityIntervals and returns the data saved in the database.
     * @param {AvailabilityIntervalCreateManyAndReturnArgs} args - Arguments to create many AvailabilityIntervals.
     * @example
     * // Create many AvailabilityIntervals
     * const availabilityInterval = await prisma.availabilityInterval.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AvailabilityIntervals and only return the `id`
     * const availabilityIntervalWithIdOnly = await prisma.availabilityInterval.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AvailabilityIntervalCreateManyAndReturnArgs>(args?: SelectSubset<T, AvailabilityIntervalCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AvailabilityIntervalPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AvailabilityInterval.
     * @param {AvailabilityIntervalDeleteArgs} args - Arguments to delete one AvailabilityInterval.
     * @example
     * // Delete one AvailabilityInterval
     * const AvailabilityInterval = await prisma.availabilityInterval.delete({
     *   where: {
     *     // ... filter to delete one AvailabilityInterval
     *   }
     * })
     * 
     */
    delete<T extends AvailabilityIntervalDeleteArgs>(args: SelectSubset<T, AvailabilityIntervalDeleteArgs<ExtArgs>>): Prisma__AvailabilityIntervalClient<$Result.GetResult<Prisma.$AvailabilityIntervalPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AvailabilityInterval.
     * @param {AvailabilityIntervalUpdateArgs} args - Arguments to update one AvailabilityInterval.
     * @example
     * // Update one AvailabilityInterval
     * const availabilityInterval = await prisma.availabilityInterval.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AvailabilityIntervalUpdateArgs>(args: SelectSubset<T, AvailabilityIntervalUpdateArgs<ExtArgs>>): Prisma__AvailabilityIntervalClient<$Result.GetResult<Prisma.$AvailabilityIntervalPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AvailabilityIntervals.
     * @param {AvailabilityIntervalDeleteManyArgs} args - Arguments to filter AvailabilityIntervals to delete.
     * @example
     * // Delete a few AvailabilityIntervals
     * const { count } = await prisma.availabilityInterval.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AvailabilityIntervalDeleteManyArgs>(args?: SelectSubset<T, AvailabilityIntervalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AvailabilityIntervals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvailabilityIntervalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AvailabilityIntervals
     * const availabilityInterval = await prisma.availabilityInterval.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AvailabilityIntervalUpdateManyArgs>(args: SelectSubset<T, AvailabilityIntervalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AvailabilityIntervals and returns the data updated in the database.
     * @param {AvailabilityIntervalUpdateManyAndReturnArgs} args - Arguments to update many AvailabilityIntervals.
     * @example
     * // Update many AvailabilityIntervals
     * const availabilityInterval = await prisma.availabilityInterval.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AvailabilityIntervals and only return the `id`
     * const availabilityIntervalWithIdOnly = await prisma.availabilityInterval.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AvailabilityIntervalUpdateManyAndReturnArgs>(args: SelectSubset<T, AvailabilityIntervalUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AvailabilityIntervalPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AvailabilityInterval.
     * @param {AvailabilityIntervalUpsertArgs} args - Arguments to update or create a AvailabilityInterval.
     * @example
     * // Update or create a AvailabilityInterval
     * const availabilityInterval = await prisma.availabilityInterval.upsert({
     *   create: {
     *     // ... data to create a AvailabilityInterval
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AvailabilityInterval we want to update
     *   }
     * })
     */
    upsert<T extends AvailabilityIntervalUpsertArgs>(args: SelectSubset<T, AvailabilityIntervalUpsertArgs<ExtArgs>>): Prisma__AvailabilityIntervalClient<$Result.GetResult<Prisma.$AvailabilityIntervalPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AvailabilityIntervals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvailabilityIntervalCountArgs} args - Arguments to filter AvailabilityIntervals to count.
     * @example
     * // Count the number of AvailabilityIntervals
     * const count = await prisma.availabilityInterval.count({
     *   where: {
     *     // ... the filter for the AvailabilityIntervals we want to count
     *   }
     * })
    **/
    count<T extends AvailabilityIntervalCountArgs>(
      args?: Subset<T, AvailabilityIntervalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AvailabilityIntervalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AvailabilityInterval.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvailabilityIntervalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AvailabilityIntervalAggregateArgs>(args: Subset<T, AvailabilityIntervalAggregateArgs>): Prisma.PrismaPromise<GetAvailabilityIntervalAggregateType<T>>

    /**
     * Group by AvailabilityInterval.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvailabilityIntervalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AvailabilityIntervalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AvailabilityIntervalGroupByArgs['orderBy'] }
        : { orderBy?: AvailabilityIntervalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AvailabilityIntervalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAvailabilityIntervalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AvailabilityInterval model
   */
  readonly fields: AvailabilityIntervalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AvailabilityInterval.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AvailabilityIntervalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    contract<T extends ContractDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContractDefaultArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AvailabilityInterval model
   */ 
  interface AvailabilityIntervalFieldRefs {
    readonly id: FieldRef<"AvailabilityInterval", 'String'>
    readonly day: FieldRef<"AvailabilityInterval", 'DayOfWeek'>
    readonly allDay: FieldRef<"AvailabilityInterval", 'Boolean'>
    readonly startTime: FieldRef<"AvailabilityInterval", 'String'>
    readonly endTime: FieldRef<"AvailabilityInterval", 'String'>
    readonly contractId: FieldRef<"AvailabilityInterval", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AvailabilityInterval findUnique
   */
  export type AvailabilityIntervalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AvailabilityInterval
     */
    select?: AvailabilityIntervalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AvailabilityInterval
     */
    omit?: AvailabilityIntervalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvailabilityIntervalInclude<ExtArgs> | null
    /**
     * Filter, which AvailabilityInterval to fetch.
     */
    where: AvailabilityIntervalWhereUniqueInput
  }

  /**
   * AvailabilityInterval findUniqueOrThrow
   */
  export type AvailabilityIntervalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AvailabilityInterval
     */
    select?: AvailabilityIntervalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AvailabilityInterval
     */
    omit?: AvailabilityIntervalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvailabilityIntervalInclude<ExtArgs> | null
    /**
     * Filter, which AvailabilityInterval to fetch.
     */
    where: AvailabilityIntervalWhereUniqueInput
  }

  /**
   * AvailabilityInterval findFirst
   */
  export type AvailabilityIntervalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AvailabilityInterval
     */
    select?: AvailabilityIntervalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AvailabilityInterval
     */
    omit?: AvailabilityIntervalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvailabilityIntervalInclude<ExtArgs> | null
    /**
     * Filter, which AvailabilityInterval to fetch.
     */
    where?: AvailabilityIntervalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AvailabilityIntervals to fetch.
     */
    orderBy?: AvailabilityIntervalOrderByWithRelationInput | AvailabilityIntervalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AvailabilityIntervals.
     */
    cursor?: AvailabilityIntervalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AvailabilityIntervals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AvailabilityIntervals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AvailabilityIntervals.
     */
    distinct?: AvailabilityIntervalScalarFieldEnum | AvailabilityIntervalScalarFieldEnum[]
  }

  /**
   * AvailabilityInterval findFirstOrThrow
   */
  export type AvailabilityIntervalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AvailabilityInterval
     */
    select?: AvailabilityIntervalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AvailabilityInterval
     */
    omit?: AvailabilityIntervalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvailabilityIntervalInclude<ExtArgs> | null
    /**
     * Filter, which AvailabilityInterval to fetch.
     */
    where?: AvailabilityIntervalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AvailabilityIntervals to fetch.
     */
    orderBy?: AvailabilityIntervalOrderByWithRelationInput | AvailabilityIntervalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AvailabilityIntervals.
     */
    cursor?: AvailabilityIntervalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AvailabilityIntervals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AvailabilityIntervals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AvailabilityIntervals.
     */
    distinct?: AvailabilityIntervalScalarFieldEnum | AvailabilityIntervalScalarFieldEnum[]
  }

  /**
   * AvailabilityInterval findMany
   */
  export type AvailabilityIntervalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AvailabilityInterval
     */
    select?: AvailabilityIntervalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AvailabilityInterval
     */
    omit?: AvailabilityIntervalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvailabilityIntervalInclude<ExtArgs> | null
    /**
     * Filter, which AvailabilityIntervals to fetch.
     */
    where?: AvailabilityIntervalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AvailabilityIntervals to fetch.
     */
    orderBy?: AvailabilityIntervalOrderByWithRelationInput | AvailabilityIntervalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AvailabilityIntervals.
     */
    cursor?: AvailabilityIntervalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AvailabilityIntervals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AvailabilityIntervals.
     */
    skip?: number
    distinct?: AvailabilityIntervalScalarFieldEnum | AvailabilityIntervalScalarFieldEnum[]
  }

  /**
   * AvailabilityInterval create
   */
  export type AvailabilityIntervalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AvailabilityInterval
     */
    select?: AvailabilityIntervalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AvailabilityInterval
     */
    omit?: AvailabilityIntervalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvailabilityIntervalInclude<ExtArgs> | null
    /**
     * The data needed to create a AvailabilityInterval.
     */
    data: XOR<AvailabilityIntervalCreateInput, AvailabilityIntervalUncheckedCreateInput>
  }

  /**
   * AvailabilityInterval createMany
   */
  export type AvailabilityIntervalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AvailabilityIntervals.
     */
    data: AvailabilityIntervalCreateManyInput | AvailabilityIntervalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AvailabilityInterval createManyAndReturn
   */
  export type AvailabilityIntervalCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AvailabilityInterval
     */
    select?: AvailabilityIntervalSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AvailabilityInterval
     */
    omit?: AvailabilityIntervalOmit<ExtArgs> | null
    /**
     * The data used to create many AvailabilityIntervals.
     */
    data: AvailabilityIntervalCreateManyInput | AvailabilityIntervalCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvailabilityIntervalIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AvailabilityInterval update
   */
  export type AvailabilityIntervalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AvailabilityInterval
     */
    select?: AvailabilityIntervalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AvailabilityInterval
     */
    omit?: AvailabilityIntervalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvailabilityIntervalInclude<ExtArgs> | null
    /**
     * The data needed to update a AvailabilityInterval.
     */
    data: XOR<AvailabilityIntervalUpdateInput, AvailabilityIntervalUncheckedUpdateInput>
    /**
     * Choose, which AvailabilityInterval to update.
     */
    where: AvailabilityIntervalWhereUniqueInput
  }

  /**
   * AvailabilityInterval updateMany
   */
  export type AvailabilityIntervalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AvailabilityIntervals.
     */
    data: XOR<AvailabilityIntervalUpdateManyMutationInput, AvailabilityIntervalUncheckedUpdateManyInput>
    /**
     * Filter which AvailabilityIntervals to update
     */
    where?: AvailabilityIntervalWhereInput
    /**
     * Limit how many AvailabilityIntervals to update.
     */
    limit?: number
  }

  /**
   * AvailabilityInterval updateManyAndReturn
   */
  export type AvailabilityIntervalUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AvailabilityInterval
     */
    select?: AvailabilityIntervalSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AvailabilityInterval
     */
    omit?: AvailabilityIntervalOmit<ExtArgs> | null
    /**
     * The data used to update AvailabilityIntervals.
     */
    data: XOR<AvailabilityIntervalUpdateManyMutationInput, AvailabilityIntervalUncheckedUpdateManyInput>
    /**
     * Filter which AvailabilityIntervals to update
     */
    where?: AvailabilityIntervalWhereInput
    /**
     * Limit how many AvailabilityIntervals to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvailabilityIntervalIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AvailabilityInterval upsert
   */
  export type AvailabilityIntervalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AvailabilityInterval
     */
    select?: AvailabilityIntervalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AvailabilityInterval
     */
    omit?: AvailabilityIntervalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvailabilityIntervalInclude<ExtArgs> | null
    /**
     * The filter to search for the AvailabilityInterval to update in case it exists.
     */
    where: AvailabilityIntervalWhereUniqueInput
    /**
     * In case the AvailabilityInterval found by the `where` argument doesn't exist, create a new AvailabilityInterval with this data.
     */
    create: XOR<AvailabilityIntervalCreateInput, AvailabilityIntervalUncheckedCreateInput>
    /**
     * In case the AvailabilityInterval was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AvailabilityIntervalUpdateInput, AvailabilityIntervalUncheckedUpdateInput>
  }

  /**
   * AvailabilityInterval delete
   */
  export type AvailabilityIntervalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AvailabilityInterval
     */
    select?: AvailabilityIntervalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AvailabilityInterval
     */
    omit?: AvailabilityIntervalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvailabilityIntervalInclude<ExtArgs> | null
    /**
     * Filter which AvailabilityInterval to delete.
     */
    where: AvailabilityIntervalWhereUniqueInput
  }

  /**
   * AvailabilityInterval deleteMany
   */
  export type AvailabilityIntervalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AvailabilityIntervals to delete
     */
    where?: AvailabilityIntervalWhereInput
    /**
     * Limit how many AvailabilityIntervals to delete.
     */
    limit?: number
  }

  /**
   * AvailabilityInterval without action
   */
  export type AvailabilityIntervalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AvailabilityInterval
     */
    select?: AvailabilityIntervalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AvailabilityInterval
     */
    omit?: AvailabilityIntervalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvailabilityIntervalInclude<ExtArgs> | null
  }


  /**
   * Model TimeRecord
   */

  export type AggregateTimeRecord = {
    _count: TimeRecordCountAggregateOutputType | null
    _min: TimeRecordMinAggregateOutputType | null
    _max: TimeRecordMaxAggregateOutputType | null
  }

  export type TimeRecordMinAggregateOutputType = {
    id: string | null
    date: Date | null
    checkIn: Date | null
    checkOut: Date | null
    employeeId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TimeRecordMaxAggregateOutputType = {
    id: string | null
    date: Date | null
    checkIn: Date | null
    checkOut: Date | null
    employeeId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TimeRecordCountAggregateOutputType = {
    id: number
    date: number
    checkIn: number
    checkOut: number
    employeeId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TimeRecordMinAggregateInputType = {
    id?: true
    date?: true
    checkIn?: true
    checkOut?: true
    employeeId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TimeRecordMaxAggregateInputType = {
    id?: true
    date?: true
    checkIn?: true
    checkOut?: true
    employeeId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TimeRecordCountAggregateInputType = {
    id?: true
    date?: true
    checkIn?: true
    checkOut?: true
    employeeId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TimeRecordAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TimeRecord to aggregate.
     */
    where?: TimeRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TimeRecords to fetch.
     */
    orderBy?: TimeRecordOrderByWithRelationInput | TimeRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TimeRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TimeRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TimeRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TimeRecords
    **/
    _count?: true | TimeRecordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TimeRecordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TimeRecordMaxAggregateInputType
  }

  export type GetTimeRecordAggregateType<T extends TimeRecordAggregateArgs> = {
        [P in keyof T & keyof AggregateTimeRecord]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTimeRecord[P]>
      : GetScalarType<T[P], AggregateTimeRecord[P]>
  }




  export type TimeRecordGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TimeRecordWhereInput
    orderBy?: TimeRecordOrderByWithAggregationInput | TimeRecordOrderByWithAggregationInput[]
    by: TimeRecordScalarFieldEnum[] | TimeRecordScalarFieldEnum
    having?: TimeRecordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TimeRecordCountAggregateInputType | true
    _min?: TimeRecordMinAggregateInputType
    _max?: TimeRecordMaxAggregateInputType
  }

  export type TimeRecordGroupByOutputType = {
    id: string
    date: Date
    checkIn: Date
    checkOut: Date | null
    employeeId: string
    createdAt: Date
    updatedAt: Date
    _count: TimeRecordCountAggregateOutputType | null
    _min: TimeRecordMinAggregateOutputType | null
    _max: TimeRecordMaxAggregateOutputType | null
  }

  type GetTimeRecordGroupByPayload<T extends TimeRecordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TimeRecordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TimeRecordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TimeRecordGroupByOutputType[P]>
            : GetScalarType<T[P], TimeRecordGroupByOutputType[P]>
        }
      >
    >


  export type TimeRecordSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    checkIn?: boolean
    checkOut?: boolean
    employeeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["timeRecord"]>

  export type TimeRecordSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    checkIn?: boolean
    checkOut?: boolean
    employeeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["timeRecord"]>

  export type TimeRecordSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    checkIn?: boolean
    checkOut?: boolean
    employeeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["timeRecord"]>

  export type TimeRecordSelectScalar = {
    id?: boolean
    date?: boolean
    checkIn?: boolean
    checkOut?: boolean
    employeeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TimeRecordOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "date" | "checkIn" | "checkOut" | "employeeId" | "createdAt" | "updatedAt", ExtArgs["result"]["timeRecord"]>
  export type TimeRecordInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }
  export type TimeRecordIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }
  export type TimeRecordIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }

  export type $TimeRecordPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TimeRecord"
    objects: {
      employee: Prisma.$EmployeePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      date: Date
      checkIn: Date
      checkOut: Date | null
      employeeId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["timeRecord"]>
    composites: {}
  }

  type TimeRecordGetPayload<S extends boolean | null | undefined | TimeRecordDefaultArgs> = $Result.GetResult<Prisma.$TimeRecordPayload, S>

  type TimeRecordCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TimeRecordFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TimeRecordCountAggregateInputType | true
    }

  export interface TimeRecordDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TimeRecord'], meta: { name: 'TimeRecord' } }
    /**
     * Find zero or one TimeRecord that matches the filter.
     * @param {TimeRecordFindUniqueArgs} args - Arguments to find a TimeRecord
     * @example
     * // Get one TimeRecord
     * const timeRecord = await prisma.timeRecord.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TimeRecordFindUniqueArgs>(args: SelectSubset<T, TimeRecordFindUniqueArgs<ExtArgs>>): Prisma__TimeRecordClient<$Result.GetResult<Prisma.$TimeRecordPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TimeRecord that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TimeRecordFindUniqueOrThrowArgs} args - Arguments to find a TimeRecord
     * @example
     * // Get one TimeRecord
     * const timeRecord = await prisma.timeRecord.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TimeRecordFindUniqueOrThrowArgs>(args: SelectSubset<T, TimeRecordFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TimeRecordClient<$Result.GetResult<Prisma.$TimeRecordPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TimeRecord that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeRecordFindFirstArgs} args - Arguments to find a TimeRecord
     * @example
     * // Get one TimeRecord
     * const timeRecord = await prisma.timeRecord.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TimeRecordFindFirstArgs>(args?: SelectSubset<T, TimeRecordFindFirstArgs<ExtArgs>>): Prisma__TimeRecordClient<$Result.GetResult<Prisma.$TimeRecordPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TimeRecord that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeRecordFindFirstOrThrowArgs} args - Arguments to find a TimeRecord
     * @example
     * // Get one TimeRecord
     * const timeRecord = await prisma.timeRecord.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TimeRecordFindFirstOrThrowArgs>(args?: SelectSubset<T, TimeRecordFindFirstOrThrowArgs<ExtArgs>>): Prisma__TimeRecordClient<$Result.GetResult<Prisma.$TimeRecordPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TimeRecords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeRecordFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TimeRecords
     * const timeRecords = await prisma.timeRecord.findMany()
     * 
     * // Get first 10 TimeRecords
     * const timeRecords = await prisma.timeRecord.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const timeRecordWithIdOnly = await prisma.timeRecord.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TimeRecordFindManyArgs>(args?: SelectSubset<T, TimeRecordFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimeRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TimeRecord.
     * @param {TimeRecordCreateArgs} args - Arguments to create a TimeRecord.
     * @example
     * // Create one TimeRecord
     * const TimeRecord = await prisma.timeRecord.create({
     *   data: {
     *     // ... data to create a TimeRecord
     *   }
     * })
     * 
     */
    create<T extends TimeRecordCreateArgs>(args: SelectSubset<T, TimeRecordCreateArgs<ExtArgs>>): Prisma__TimeRecordClient<$Result.GetResult<Prisma.$TimeRecordPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TimeRecords.
     * @param {TimeRecordCreateManyArgs} args - Arguments to create many TimeRecords.
     * @example
     * // Create many TimeRecords
     * const timeRecord = await prisma.timeRecord.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TimeRecordCreateManyArgs>(args?: SelectSubset<T, TimeRecordCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TimeRecords and returns the data saved in the database.
     * @param {TimeRecordCreateManyAndReturnArgs} args - Arguments to create many TimeRecords.
     * @example
     * // Create many TimeRecords
     * const timeRecord = await prisma.timeRecord.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TimeRecords and only return the `id`
     * const timeRecordWithIdOnly = await prisma.timeRecord.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TimeRecordCreateManyAndReturnArgs>(args?: SelectSubset<T, TimeRecordCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimeRecordPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TimeRecord.
     * @param {TimeRecordDeleteArgs} args - Arguments to delete one TimeRecord.
     * @example
     * // Delete one TimeRecord
     * const TimeRecord = await prisma.timeRecord.delete({
     *   where: {
     *     // ... filter to delete one TimeRecord
     *   }
     * })
     * 
     */
    delete<T extends TimeRecordDeleteArgs>(args: SelectSubset<T, TimeRecordDeleteArgs<ExtArgs>>): Prisma__TimeRecordClient<$Result.GetResult<Prisma.$TimeRecordPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TimeRecord.
     * @param {TimeRecordUpdateArgs} args - Arguments to update one TimeRecord.
     * @example
     * // Update one TimeRecord
     * const timeRecord = await prisma.timeRecord.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TimeRecordUpdateArgs>(args: SelectSubset<T, TimeRecordUpdateArgs<ExtArgs>>): Prisma__TimeRecordClient<$Result.GetResult<Prisma.$TimeRecordPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TimeRecords.
     * @param {TimeRecordDeleteManyArgs} args - Arguments to filter TimeRecords to delete.
     * @example
     * // Delete a few TimeRecords
     * const { count } = await prisma.timeRecord.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TimeRecordDeleteManyArgs>(args?: SelectSubset<T, TimeRecordDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TimeRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeRecordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TimeRecords
     * const timeRecord = await prisma.timeRecord.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TimeRecordUpdateManyArgs>(args: SelectSubset<T, TimeRecordUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TimeRecords and returns the data updated in the database.
     * @param {TimeRecordUpdateManyAndReturnArgs} args - Arguments to update many TimeRecords.
     * @example
     * // Update many TimeRecords
     * const timeRecord = await prisma.timeRecord.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TimeRecords and only return the `id`
     * const timeRecordWithIdOnly = await prisma.timeRecord.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TimeRecordUpdateManyAndReturnArgs>(args: SelectSubset<T, TimeRecordUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimeRecordPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TimeRecord.
     * @param {TimeRecordUpsertArgs} args - Arguments to update or create a TimeRecord.
     * @example
     * // Update or create a TimeRecord
     * const timeRecord = await prisma.timeRecord.upsert({
     *   create: {
     *     // ... data to create a TimeRecord
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TimeRecord we want to update
     *   }
     * })
     */
    upsert<T extends TimeRecordUpsertArgs>(args: SelectSubset<T, TimeRecordUpsertArgs<ExtArgs>>): Prisma__TimeRecordClient<$Result.GetResult<Prisma.$TimeRecordPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TimeRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeRecordCountArgs} args - Arguments to filter TimeRecords to count.
     * @example
     * // Count the number of TimeRecords
     * const count = await prisma.timeRecord.count({
     *   where: {
     *     // ... the filter for the TimeRecords we want to count
     *   }
     * })
    **/
    count<T extends TimeRecordCountArgs>(
      args?: Subset<T, TimeRecordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TimeRecordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TimeRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeRecordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TimeRecordAggregateArgs>(args: Subset<T, TimeRecordAggregateArgs>): Prisma.PrismaPromise<GetTimeRecordAggregateType<T>>

    /**
     * Group by TimeRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeRecordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TimeRecordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TimeRecordGroupByArgs['orderBy'] }
        : { orderBy?: TimeRecordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TimeRecordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTimeRecordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TimeRecord model
   */
  readonly fields: TimeRecordFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TimeRecord.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TimeRecordClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee<T extends EmployeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeDefaultArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TimeRecord model
   */ 
  interface TimeRecordFieldRefs {
    readonly id: FieldRef<"TimeRecord", 'String'>
    readonly date: FieldRef<"TimeRecord", 'DateTime'>
    readonly checkIn: FieldRef<"TimeRecord", 'DateTime'>
    readonly checkOut: FieldRef<"TimeRecord", 'DateTime'>
    readonly employeeId: FieldRef<"TimeRecord", 'String'>
    readonly createdAt: FieldRef<"TimeRecord", 'DateTime'>
    readonly updatedAt: FieldRef<"TimeRecord", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TimeRecord findUnique
   */
  export type TimeRecordFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeRecord
     */
    select?: TimeRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeRecord
     */
    omit?: TimeRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeRecordInclude<ExtArgs> | null
    /**
     * Filter, which TimeRecord to fetch.
     */
    where: TimeRecordWhereUniqueInput
  }

  /**
   * TimeRecord findUniqueOrThrow
   */
  export type TimeRecordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeRecord
     */
    select?: TimeRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeRecord
     */
    omit?: TimeRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeRecordInclude<ExtArgs> | null
    /**
     * Filter, which TimeRecord to fetch.
     */
    where: TimeRecordWhereUniqueInput
  }

  /**
   * TimeRecord findFirst
   */
  export type TimeRecordFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeRecord
     */
    select?: TimeRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeRecord
     */
    omit?: TimeRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeRecordInclude<ExtArgs> | null
    /**
     * Filter, which TimeRecord to fetch.
     */
    where?: TimeRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TimeRecords to fetch.
     */
    orderBy?: TimeRecordOrderByWithRelationInput | TimeRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TimeRecords.
     */
    cursor?: TimeRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TimeRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TimeRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TimeRecords.
     */
    distinct?: TimeRecordScalarFieldEnum | TimeRecordScalarFieldEnum[]
  }

  /**
   * TimeRecord findFirstOrThrow
   */
  export type TimeRecordFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeRecord
     */
    select?: TimeRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeRecord
     */
    omit?: TimeRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeRecordInclude<ExtArgs> | null
    /**
     * Filter, which TimeRecord to fetch.
     */
    where?: TimeRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TimeRecords to fetch.
     */
    orderBy?: TimeRecordOrderByWithRelationInput | TimeRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TimeRecords.
     */
    cursor?: TimeRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TimeRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TimeRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TimeRecords.
     */
    distinct?: TimeRecordScalarFieldEnum | TimeRecordScalarFieldEnum[]
  }

  /**
   * TimeRecord findMany
   */
  export type TimeRecordFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeRecord
     */
    select?: TimeRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeRecord
     */
    omit?: TimeRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeRecordInclude<ExtArgs> | null
    /**
     * Filter, which TimeRecords to fetch.
     */
    where?: TimeRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TimeRecords to fetch.
     */
    orderBy?: TimeRecordOrderByWithRelationInput | TimeRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TimeRecords.
     */
    cursor?: TimeRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TimeRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TimeRecords.
     */
    skip?: number
    distinct?: TimeRecordScalarFieldEnum | TimeRecordScalarFieldEnum[]
  }

  /**
   * TimeRecord create
   */
  export type TimeRecordCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeRecord
     */
    select?: TimeRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeRecord
     */
    omit?: TimeRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeRecordInclude<ExtArgs> | null
    /**
     * The data needed to create a TimeRecord.
     */
    data: XOR<TimeRecordCreateInput, TimeRecordUncheckedCreateInput>
  }

  /**
   * TimeRecord createMany
   */
  export type TimeRecordCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TimeRecords.
     */
    data: TimeRecordCreateManyInput | TimeRecordCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TimeRecord createManyAndReturn
   */
  export type TimeRecordCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeRecord
     */
    select?: TimeRecordSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TimeRecord
     */
    omit?: TimeRecordOmit<ExtArgs> | null
    /**
     * The data used to create many TimeRecords.
     */
    data: TimeRecordCreateManyInput | TimeRecordCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeRecordIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TimeRecord update
   */
  export type TimeRecordUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeRecord
     */
    select?: TimeRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeRecord
     */
    omit?: TimeRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeRecordInclude<ExtArgs> | null
    /**
     * The data needed to update a TimeRecord.
     */
    data: XOR<TimeRecordUpdateInput, TimeRecordUncheckedUpdateInput>
    /**
     * Choose, which TimeRecord to update.
     */
    where: TimeRecordWhereUniqueInput
  }

  /**
   * TimeRecord updateMany
   */
  export type TimeRecordUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TimeRecords.
     */
    data: XOR<TimeRecordUpdateManyMutationInput, TimeRecordUncheckedUpdateManyInput>
    /**
     * Filter which TimeRecords to update
     */
    where?: TimeRecordWhereInput
    /**
     * Limit how many TimeRecords to update.
     */
    limit?: number
  }

  /**
   * TimeRecord updateManyAndReturn
   */
  export type TimeRecordUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeRecord
     */
    select?: TimeRecordSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TimeRecord
     */
    omit?: TimeRecordOmit<ExtArgs> | null
    /**
     * The data used to update TimeRecords.
     */
    data: XOR<TimeRecordUpdateManyMutationInput, TimeRecordUncheckedUpdateManyInput>
    /**
     * Filter which TimeRecords to update
     */
    where?: TimeRecordWhereInput
    /**
     * Limit how many TimeRecords to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeRecordIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TimeRecord upsert
   */
  export type TimeRecordUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeRecord
     */
    select?: TimeRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeRecord
     */
    omit?: TimeRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeRecordInclude<ExtArgs> | null
    /**
     * The filter to search for the TimeRecord to update in case it exists.
     */
    where: TimeRecordWhereUniqueInput
    /**
     * In case the TimeRecord found by the `where` argument doesn't exist, create a new TimeRecord with this data.
     */
    create: XOR<TimeRecordCreateInput, TimeRecordUncheckedCreateInput>
    /**
     * In case the TimeRecord was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TimeRecordUpdateInput, TimeRecordUncheckedUpdateInput>
  }

  /**
   * TimeRecord delete
   */
  export type TimeRecordDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeRecord
     */
    select?: TimeRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeRecord
     */
    omit?: TimeRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeRecordInclude<ExtArgs> | null
    /**
     * Filter which TimeRecord to delete.
     */
    where: TimeRecordWhereUniqueInput
  }

  /**
   * TimeRecord deleteMany
   */
  export type TimeRecordDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TimeRecords to delete
     */
    where?: TimeRecordWhereInput
    /**
     * Limit how many TimeRecords to delete.
     */
    limit?: number
  }

  /**
   * TimeRecord without action
   */
  export type TimeRecordDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeRecord
     */
    select?: TimeRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeRecord
     */
    omit?: TimeRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeRecordInclude<ExtArgs> | null
  }


  /**
   * Model Shift
   */

  export type AggregateShift = {
    _count: ShiftCountAggregateOutputType | null
    _avg: ShiftAvgAggregateOutputType | null
    _sum: ShiftSumAggregateOutputType | null
    _min: ShiftMinAggregateOutputType | null
    _max: ShiftMaxAggregateOutputType | null
  }

  export type ShiftAvgAggregateOutputType = {
    startHour: number | null
    endHour: number | null
  }

  export type ShiftSumAggregateOutputType = {
    startHour: number | null
    endHour: number | null
  }

  export type ShiftMinAggregateOutputType = {
    id: string | null
    date: Date | null
    startHour: number | null
    endHour: number | null
    shiftType: string | null
    employeeId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ShiftMaxAggregateOutputType = {
    id: string | null
    date: Date | null
    startHour: number | null
    endHour: number | null
    shiftType: string | null
    employeeId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ShiftCountAggregateOutputType = {
    id: number
    date: number
    startHour: number
    endHour: number
    shiftType: number
    employeeId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ShiftAvgAggregateInputType = {
    startHour?: true
    endHour?: true
  }

  export type ShiftSumAggregateInputType = {
    startHour?: true
    endHour?: true
  }

  export type ShiftMinAggregateInputType = {
    id?: true
    date?: true
    startHour?: true
    endHour?: true
    shiftType?: true
    employeeId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ShiftMaxAggregateInputType = {
    id?: true
    date?: true
    startHour?: true
    endHour?: true
    shiftType?: true
    employeeId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ShiftCountAggregateInputType = {
    id?: true
    date?: true
    startHour?: true
    endHour?: true
    shiftType?: true
    employeeId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ShiftAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Shift to aggregate.
     */
    where?: ShiftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shifts to fetch.
     */
    orderBy?: ShiftOrderByWithRelationInput | ShiftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ShiftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shifts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shifts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Shifts
    **/
    _count?: true | ShiftCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ShiftAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ShiftSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ShiftMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ShiftMaxAggregateInputType
  }

  export type GetShiftAggregateType<T extends ShiftAggregateArgs> = {
        [P in keyof T & keyof AggregateShift]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShift[P]>
      : GetScalarType<T[P], AggregateShift[P]>
  }




  export type ShiftGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShiftWhereInput
    orderBy?: ShiftOrderByWithAggregationInput | ShiftOrderByWithAggregationInput[]
    by: ShiftScalarFieldEnum[] | ShiftScalarFieldEnum
    having?: ShiftScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ShiftCountAggregateInputType | true
    _avg?: ShiftAvgAggregateInputType
    _sum?: ShiftSumAggregateInputType
    _min?: ShiftMinAggregateInputType
    _max?: ShiftMaxAggregateInputType
  }

  export type ShiftGroupByOutputType = {
    id: string
    date: Date
    startHour: number
    endHour: number
    shiftType: string | null
    employeeId: string
    createdAt: Date
    updatedAt: Date
    _count: ShiftCountAggregateOutputType | null
    _avg: ShiftAvgAggregateOutputType | null
    _sum: ShiftSumAggregateOutputType | null
    _min: ShiftMinAggregateOutputType | null
    _max: ShiftMaxAggregateOutputType | null
  }

  type GetShiftGroupByPayload<T extends ShiftGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ShiftGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ShiftGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ShiftGroupByOutputType[P]>
            : GetScalarType<T[P], ShiftGroupByOutputType[P]>
        }
      >
    >


  export type ShiftSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    startHour?: boolean
    endHour?: boolean
    shiftType?: boolean
    employeeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shift"]>

  export type ShiftSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    startHour?: boolean
    endHour?: boolean
    shiftType?: boolean
    employeeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shift"]>

  export type ShiftSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    startHour?: boolean
    endHour?: boolean
    shiftType?: boolean
    employeeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shift"]>

  export type ShiftSelectScalar = {
    id?: boolean
    date?: boolean
    startHour?: boolean
    endHour?: boolean
    shiftType?: boolean
    employeeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ShiftOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "date" | "startHour" | "endHour" | "shiftType" | "employeeId" | "createdAt" | "updatedAt", ExtArgs["result"]["shift"]>
  export type ShiftInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }
  export type ShiftIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }
  export type ShiftIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }

  export type $ShiftPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Shift"
    objects: {
      employee: Prisma.$EmployeePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      date: Date
      startHour: number
      endHour: number
      shiftType: string | null
      employeeId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["shift"]>
    composites: {}
  }

  type ShiftGetPayload<S extends boolean | null | undefined | ShiftDefaultArgs> = $Result.GetResult<Prisma.$ShiftPayload, S>

  type ShiftCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ShiftFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ShiftCountAggregateInputType | true
    }

  export interface ShiftDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Shift'], meta: { name: 'Shift' } }
    /**
     * Find zero or one Shift that matches the filter.
     * @param {ShiftFindUniqueArgs} args - Arguments to find a Shift
     * @example
     * // Get one Shift
     * const shift = await prisma.shift.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ShiftFindUniqueArgs>(args: SelectSubset<T, ShiftFindUniqueArgs<ExtArgs>>): Prisma__ShiftClient<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Shift that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ShiftFindUniqueOrThrowArgs} args - Arguments to find a Shift
     * @example
     * // Get one Shift
     * const shift = await prisma.shift.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ShiftFindUniqueOrThrowArgs>(args: SelectSubset<T, ShiftFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ShiftClient<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Shift that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftFindFirstArgs} args - Arguments to find a Shift
     * @example
     * // Get one Shift
     * const shift = await prisma.shift.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ShiftFindFirstArgs>(args?: SelectSubset<T, ShiftFindFirstArgs<ExtArgs>>): Prisma__ShiftClient<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Shift that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftFindFirstOrThrowArgs} args - Arguments to find a Shift
     * @example
     * // Get one Shift
     * const shift = await prisma.shift.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ShiftFindFirstOrThrowArgs>(args?: SelectSubset<T, ShiftFindFirstOrThrowArgs<ExtArgs>>): Prisma__ShiftClient<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Shifts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Shifts
     * const shifts = await prisma.shift.findMany()
     * 
     * // Get first 10 Shifts
     * const shifts = await prisma.shift.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const shiftWithIdOnly = await prisma.shift.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ShiftFindManyArgs>(args?: SelectSubset<T, ShiftFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Shift.
     * @param {ShiftCreateArgs} args - Arguments to create a Shift.
     * @example
     * // Create one Shift
     * const Shift = await prisma.shift.create({
     *   data: {
     *     // ... data to create a Shift
     *   }
     * })
     * 
     */
    create<T extends ShiftCreateArgs>(args: SelectSubset<T, ShiftCreateArgs<ExtArgs>>): Prisma__ShiftClient<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Shifts.
     * @param {ShiftCreateManyArgs} args - Arguments to create many Shifts.
     * @example
     * // Create many Shifts
     * const shift = await prisma.shift.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ShiftCreateManyArgs>(args?: SelectSubset<T, ShiftCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Shifts and returns the data saved in the database.
     * @param {ShiftCreateManyAndReturnArgs} args - Arguments to create many Shifts.
     * @example
     * // Create many Shifts
     * const shift = await prisma.shift.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Shifts and only return the `id`
     * const shiftWithIdOnly = await prisma.shift.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ShiftCreateManyAndReturnArgs>(args?: SelectSubset<T, ShiftCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Shift.
     * @param {ShiftDeleteArgs} args - Arguments to delete one Shift.
     * @example
     * // Delete one Shift
     * const Shift = await prisma.shift.delete({
     *   where: {
     *     // ... filter to delete one Shift
     *   }
     * })
     * 
     */
    delete<T extends ShiftDeleteArgs>(args: SelectSubset<T, ShiftDeleteArgs<ExtArgs>>): Prisma__ShiftClient<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Shift.
     * @param {ShiftUpdateArgs} args - Arguments to update one Shift.
     * @example
     * // Update one Shift
     * const shift = await prisma.shift.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ShiftUpdateArgs>(args: SelectSubset<T, ShiftUpdateArgs<ExtArgs>>): Prisma__ShiftClient<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Shifts.
     * @param {ShiftDeleteManyArgs} args - Arguments to filter Shifts to delete.
     * @example
     * // Delete a few Shifts
     * const { count } = await prisma.shift.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ShiftDeleteManyArgs>(args?: SelectSubset<T, ShiftDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Shifts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Shifts
     * const shift = await prisma.shift.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ShiftUpdateManyArgs>(args: SelectSubset<T, ShiftUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Shifts and returns the data updated in the database.
     * @param {ShiftUpdateManyAndReturnArgs} args - Arguments to update many Shifts.
     * @example
     * // Update many Shifts
     * const shift = await prisma.shift.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Shifts and only return the `id`
     * const shiftWithIdOnly = await prisma.shift.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ShiftUpdateManyAndReturnArgs>(args: SelectSubset<T, ShiftUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Shift.
     * @param {ShiftUpsertArgs} args - Arguments to update or create a Shift.
     * @example
     * // Update or create a Shift
     * const shift = await prisma.shift.upsert({
     *   create: {
     *     // ... data to create a Shift
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Shift we want to update
     *   }
     * })
     */
    upsert<T extends ShiftUpsertArgs>(args: SelectSubset<T, ShiftUpsertArgs<ExtArgs>>): Prisma__ShiftClient<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Shifts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftCountArgs} args - Arguments to filter Shifts to count.
     * @example
     * // Count the number of Shifts
     * const count = await prisma.shift.count({
     *   where: {
     *     // ... the filter for the Shifts we want to count
     *   }
     * })
    **/
    count<T extends ShiftCountArgs>(
      args?: Subset<T, ShiftCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ShiftCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Shift.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ShiftAggregateArgs>(args: Subset<T, ShiftAggregateArgs>): Prisma.PrismaPromise<GetShiftAggregateType<T>>

    /**
     * Group by Shift.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ShiftGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ShiftGroupByArgs['orderBy'] }
        : { orderBy?: ShiftGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ShiftGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShiftGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Shift model
   */
  readonly fields: ShiftFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Shift.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ShiftClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee<T extends EmployeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeDefaultArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Shift model
   */ 
  interface ShiftFieldRefs {
    readonly id: FieldRef<"Shift", 'String'>
    readonly date: FieldRef<"Shift", 'DateTime'>
    readonly startHour: FieldRef<"Shift", 'Float'>
    readonly endHour: FieldRef<"Shift", 'Float'>
    readonly shiftType: FieldRef<"Shift", 'String'>
    readonly employeeId: FieldRef<"Shift", 'String'>
    readonly createdAt: FieldRef<"Shift", 'DateTime'>
    readonly updatedAt: FieldRef<"Shift", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Shift findUnique
   */
  export type ShiftFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shift
     */
    omit?: ShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
    /**
     * Filter, which Shift to fetch.
     */
    where: ShiftWhereUniqueInput
  }

  /**
   * Shift findUniqueOrThrow
   */
  export type ShiftFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shift
     */
    omit?: ShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
    /**
     * Filter, which Shift to fetch.
     */
    where: ShiftWhereUniqueInput
  }

  /**
   * Shift findFirst
   */
  export type ShiftFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shift
     */
    omit?: ShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
    /**
     * Filter, which Shift to fetch.
     */
    where?: ShiftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shifts to fetch.
     */
    orderBy?: ShiftOrderByWithRelationInput | ShiftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Shifts.
     */
    cursor?: ShiftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shifts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shifts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Shifts.
     */
    distinct?: ShiftScalarFieldEnum | ShiftScalarFieldEnum[]
  }

  /**
   * Shift findFirstOrThrow
   */
  export type ShiftFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shift
     */
    omit?: ShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
    /**
     * Filter, which Shift to fetch.
     */
    where?: ShiftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shifts to fetch.
     */
    orderBy?: ShiftOrderByWithRelationInput | ShiftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Shifts.
     */
    cursor?: ShiftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shifts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shifts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Shifts.
     */
    distinct?: ShiftScalarFieldEnum | ShiftScalarFieldEnum[]
  }

  /**
   * Shift findMany
   */
  export type ShiftFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shift
     */
    omit?: ShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
    /**
     * Filter, which Shifts to fetch.
     */
    where?: ShiftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shifts to fetch.
     */
    orderBy?: ShiftOrderByWithRelationInput | ShiftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Shifts.
     */
    cursor?: ShiftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shifts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shifts.
     */
    skip?: number
    distinct?: ShiftScalarFieldEnum | ShiftScalarFieldEnum[]
  }

  /**
   * Shift create
   */
  export type ShiftCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shift
     */
    omit?: ShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
    /**
     * The data needed to create a Shift.
     */
    data: XOR<ShiftCreateInput, ShiftUncheckedCreateInput>
  }

  /**
   * Shift createMany
   */
  export type ShiftCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Shifts.
     */
    data: ShiftCreateManyInput | ShiftCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Shift createManyAndReturn
   */
  export type ShiftCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Shift
     */
    omit?: ShiftOmit<ExtArgs> | null
    /**
     * The data used to create many Shifts.
     */
    data: ShiftCreateManyInput | ShiftCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Shift update
   */
  export type ShiftUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shift
     */
    omit?: ShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
    /**
     * The data needed to update a Shift.
     */
    data: XOR<ShiftUpdateInput, ShiftUncheckedUpdateInput>
    /**
     * Choose, which Shift to update.
     */
    where: ShiftWhereUniqueInput
  }

  /**
   * Shift updateMany
   */
  export type ShiftUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Shifts.
     */
    data: XOR<ShiftUpdateManyMutationInput, ShiftUncheckedUpdateManyInput>
    /**
     * Filter which Shifts to update
     */
    where?: ShiftWhereInput
    /**
     * Limit how many Shifts to update.
     */
    limit?: number
  }

  /**
   * Shift updateManyAndReturn
   */
  export type ShiftUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Shift
     */
    omit?: ShiftOmit<ExtArgs> | null
    /**
     * The data used to update Shifts.
     */
    data: XOR<ShiftUpdateManyMutationInput, ShiftUncheckedUpdateManyInput>
    /**
     * Filter which Shifts to update
     */
    where?: ShiftWhereInput
    /**
     * Limit how many Shifts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Shift upsert
   */
  export type ShiftUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shift
     */
    omit?: ShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
    /**
     * The filter to search for the Shift to update in case it exists.
     */
    where: ShiftWhereUniqueInput
    /**
     * In case the Shift found by the `where` argument doesn't exist, create a new Shift with this data.
     */
    create: XOR<ShiftCreateInput, ShiftUncheckedCreateInput>
    /**
     * In case the Shift was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ShiftUpdateInput, ShiftUncheckedUpdateInput>
  }

  /**
   * Shift delete
   */
  export type ShiftDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shift
     */
    omit?: ShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
    /**
     * Filter which Shift to delete.
     */
    where: ShiftWhereUniqueInput
  }

  /**
   * Shift deleteMany
   */
  export type ShiftDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Shifts to delete
     */
    where?: ShiftWhereInput
    /**
     * Limit how many Shifts to delete.
     */
    limit?: number
  }

  /**
   * Shift without action
   */
  export type ShiftDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shift
     */
    omit?: ShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
  }


  /**
   * Model DayLock
   */

  export type AggregateDayLock = {
    _count: DayLockCountAggregateOutputType | null
    _min: DayLockMinAggregateOutputType | null
    _max: DayLockMaxAggregateOutputType | null
  }

  export type DayLockMinAggregateOutputType = {
    id: string | null
    date: Date | null
    locked: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DayLockMaxAggregateOutputType = {
    id: string | null
    date: Date | null
    locked: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DayLockCountAggregateOutputType = {
    id: number
    date: number
    locked: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DayLockMinAggregateInputType = {
    id?: true
    date?: true
    locked?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DayLockMaxAggregateInputType = {
    id?: true
    date?: true
    locked?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DayLockCountAggregateInputType = {
    id?: true
    date?: true
    locked?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DayLockAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DayLock to aggregate.
     */
    where?: DayLockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DayLocks to fetch.
     */
    orderBy?: DayLockOrderByWithRelationInput | DayLockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DayLockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DayLocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DayLocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DayLocks
    **/
    _count?: true | DayLockCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DayLockMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DayLockMaxAggregateInputType
  }

  export type GetDayLockAggregateType<T extends DayLockAggregateArgs> = {
        [P in keyof T & keyof AggregateDayLock]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDayLock[P]>
      : GetScalarType<T[P], AggregateDayLock[P]>
  }




  export type DayLockGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DayLockWhereInput
    orderBy?: DayLockOrderByWithAggregationInput | DayLockOrderByWithAggregationInput[]
    by: DayLockScalarFieldEnum[] | DayLockScalarFieldEnum
    having?: DayLockScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DayLockCountAggregateInputType | true
    _min?: DayLockMinAggregateInputType
    _max?: DayLockMaxAggregateInputType
  }

  export type DayLockGroupByOutputType = {
    id: string
    date: Date
    locked: boolean
    createdAt: Date
    updatedAt: Date
    _count: DayLockCountAggregateOutputType | null
    _min: DayLockMinAggregateOutputType | null
    _max: DayLockMaxAggregateOutputType | null
  }

  type GetDayLockGroupByPayload<T extends DayLockGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DayLockGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DayLockGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DayLockGroupByOutputType[P]>
            : GetScalarType<T[P], DayLockGroupByOutputType[P]>
        }
      >
    >


  export type DayLockSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    locked?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["dayLock"]>

  export type DayLockSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    locked?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["dayLock"]>

  export type DayLockSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    locked?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["dayLock"]>

  export type DayLockSelectScalar = {
    id?: boolean
    date?: boolean
    locked?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DayLockOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "date" | "locked" | "createdAt" | "updatedAt", ExtArgs["result"]["dayLock"]>

  export type $DayLockPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DayLock"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      date: Date
      locked: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["dayLock"]>
    composites: {}
  }

  type DayLockGetPayload<S extends boolean | null | undefined | DayLockDefaultArgs> = $Result.GetResult<Prisma.$DayLockPayload, S>

  type DayLockCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DayLockFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DayLockCountAggregateInputType | true
    }

  export interface DayLockDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DayLock'], meta: { name: 'DayLock' } }
    /**
     * Find zero or one DayLock that matches the filter.
     * @param {DayLockFindUniqueArgs} args - Arguments to find a DayLock
     * @example
     * // Get one DayLock
     * const dayLock = await prisma.dayLock.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DayLockFindUniqueArgs>(args: SelectSubset<T, DayLockFindUniqueArgs<ExtArgs>>): Prisma__DayLockClient<$Result.GetResult<Prisma.$DayLockPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DayLock that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DayLockFindUniqueOrThrowArgs} args - Arguments to find a DayLock
     * @example
     * // Get one DayLock
     * const dayLock = await prisma.dayLock.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DayLockFindUniqueOrThrowArgs>(args: SelectSubset<T, DayLockFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DayLockClient<$Result.GetResult<Prisma.$DayLockPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DayLock that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DayLockFindFirstArgs} args - Arguments to find a DayLock
     * @example
     * // Get one DayLock
     * const dayLock = await prisma.dayLock.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DayLockFindFirstArgs>(args?: SelectSubset<T, DayLockFindFirstArgs<ExtArgs>>): Prisma__DayLockClient<$Result.GetResult<Prisma.$DayLockPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DayLock that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DayLockFindFirstOrThrowArgs} args - Arguments to find a DayLock
     * @example
     * // Get one DayLock
     * const dayLock = await prisma.dayLock.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DayLockFindFirstOrThrowArgs>(args?: SelectSubset<T, DayLockFindFirstOrThrowArgs<ExtArgs>>): Prisma__DayLockClient<$Result.GetResult<Prisma.$DayLockPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DayLocks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DayLockFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DayLocks
     * const dayLocks = await prisma.dayLock.findMany()
     * 
     * // Get first 10 DayLocks
     * const dayLocks = await prisma.dayLock.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dayLockWithIdOnly = await prisma.dayLock.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DayLockFindManyArgs>(args?: SelectSubset<T, DayLockFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DayLockPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DayLock.
     * @param {DayLockCreateArgs} args - Arguments to create a DayLock.
     * @example
     * // Create one DayLock
     * const DayLock = await prisma.dayLock.create({
     *   data: {
     *     // ... data to create a DayLock
     *   }
     * })
     * 
     */
    create<T extends DayLockCreateArgs>(args: SelectSubset<T, DayLockCreateArgs<ExtArgs>>): Prisma__DayLockClient<$Result.GetResult<Prisma.$DayLockPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DayLocks.
     * @param {DayLockCreateManyArgs} args - Arguments to create many DayLocks.
     * @example
     * // Create many DayLocks
     * const dayLock = await prisma.dayLock.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DayLockCreateManyArgs>(args?: SelectSubset<T, DayLockCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DayLocks and returns the data saved in the database.
     * @param {DayLockCreateManyAndReturnArgs} args - Arguments to create many DayLocks.
     * @example
     * // Create many DayLocks
     * const dayLock = await prisma.dayLock.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DayLocks and only return the `id`
     * const dayLockWithIdOnly = await prisma.dayLock.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DayLockCreateManyAndReturnArgs>(args?: SelectSubset<T, DayLockCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DayLockPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DayLock.
     * @param {DayLockDeleteArgs} args - Arguments to delete one DayLock.
     * @example
     * // Delete one DayLock
     * const DayLock = await prisma.dayLock.delete({
     *   where: {
     *     // ... filter to delete one DayLock
     *   }
     * })
     * 
     */
    delete<T extends DayLockDeleteArgs>(args: SelectSubset<T, DayLockDeleteArgs<ExtArgs>>): Prisma__DayLockClient<$Result.GetResult<Prisma.$DayLockPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DayLock.
     * @param {DayLockUpdateArgs} args - Arguments to update one DayLock.
     * @example
     * // Update one DayLock
     * const dayLock = await prisma.dayLock.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DayLockUpdateArgs>(args: SelectSubset<T, DayLockUpdateArgs<ExtArgs>>): Prisma__DayLockClient<$Result.GetResult<Prisma.$DayLockPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DayLocks.
     * @param {DayLockDeleteManyArgs} args - Arguments to filter DayLocks to delete.
     * @example
     * // Delete a few DayLocks
     * const { count } = await prisma.dayLock.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DayLockDeleteManyArgs>(args?: SelectSubset<T, DayLockDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DayLocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DayLockUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DayLocks
     * const dayLock = await prisma.dayLock.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DayLockUpdateManyArgs>(args: SelectSubset<T, DayLockUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DayLocks and returns the data updated in the database.
     * @param {DayLockUpdateManyAndReturnArgs} args - Arguments to update many DayLocks.
     * @example
     * // Update many DayLocks
     * const dayLock = await prisma.dayLock.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DayLocks and only return the `id`
     * const dayLockWithIdOnly = await prisma.dayLock.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DayLockUpdateManyAndReturnArgs>(args: SelectSubset<T, DayLockUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DayLockPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DayLock.
     * @param {DayLockUpsertArgs} args - Arguments to update or create a DayLock.
     * @example
     * // Update or create a DayLock
     * const dayLock = await prisma.dayLock.upsert({
     *   create: {
     *     // ... data to create a DayLock
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DayLock we want to update
     *   }
     * })
     */
    upsert<T extends DayLockUpsertArgs>(args: SelectSubset<T, DayLockUpsertArgs<ExtArgs>>): Prisma__DayLockClient<$Result.GetResult<Prisma.$DayLockPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DayLocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DayLockCountArgs} args - Arguments to filter DayLocks to count.
     * @example
     * // Count the number of DayLocks
     * const count = await prisma.dayLock.count({
     *   where: {
     *     // ... the filter for the DayLocks we want to count
     *   }
     * })
    **/
    count<T extends DayLockCountArgs>(
      args?: Subset<T, DayLockCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DayLockCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DayLock.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DayLockAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DayLockAggregateArgs>(args: Subset<T, DayLockAggregateArgs>): Prisma.PrismaPromise<GetDayLockAggregateType<T>>

    /**
     * Group by DayLock.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DayLockGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DayLockGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DayLockGroupByArgs['orderBy'] }
        : { orderBy?: DayLockGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DayLockGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDayLockGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DayLock model
   */
  readonly fields: DayLockFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DayLock.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DayLockClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DayLock model
   */ 
  interface DayLockFieldRefs {
    readonly id: FieldRef<"DayLock", 'String'>
    readonly date: FieldRef<"DayLock", 'DateTime'>
    readonly locked: FieldRef<"DayLock", 'Boolean'>
    readonly createdAt: FieldRef<"DayLock", 'DateTime'>
    readonly updatedAt: FieldRef<"DayLock", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DayLock findUnique
   */
  export type DayLockFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DayLock
     */
    select?: DayLockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DayLock
     */
    omit?: DayLockOmit<ExtArgs> | null
    /**
     * Filter, which DayLock to fetch.
     */
    where: DayLockWhereUniqueInput
  }

  /**
   * DayLock findUniqueOrThrow
   */
  export type DayLockFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DayLock
     */
    select?: DayLockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DayLock
     */
    omit?: DayLockOmit<ExtArgs> | null
    /**
     * Filter, which DayLock to fetch.
     */
    where: DayLockWhereUniqueInput
  }

  /**
   * DayLock findFirst
   */
  export type DayLockFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DayLock
     */
    select?: DayLockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DayLock
     */
    omit?: DayLockOmit<ExtArgs> | null
    /**
     * Filter, which DayLock to fetch.
     */
    where?: DayLockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DayLocks to fetch.
     */
    orderBy?: DayLockOrderByWithRelationInput | DayLockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DayLocks.
     */
    cursor?: DayLockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DayLocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DayLocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DayLocks.
     */
    distinct?: DayLockScalarFieldEnum | DayLockScalarFieldEnum[]
  }

  /**
   * DayLock findFirstOrThrow
   */
  export type DayLockFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DayLock
     */
    select?: DayLockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DayLock
     */
    omit?: DayLockOmit<ExtArgs> | null
    /**
     * Filter, which DayLock to fetch.
     */
    where?: DayLockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DayLocks to fetch.
     */
    orderBy?: DayLockOrderByWithRelationInput | DayLockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DayLocks.
     */
    cursor?: DayLockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DayLocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DayLocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DayLocks.
     */
    distinct?: DayLockScalarFieldEnum | DayLockScalarFieldEnum[]
  }

  /**
   * DayLock findMany
   */
  export type DayLockFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DayLock
     */
    select?: DayLockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DayLock
     */
    omit?: DayLockOmit<ExtArgs> | null
    /**
     * Filter, which DayLocks to fetch.
     */
    where?: DayLockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DayLocks to fetch.
     */
    orderBy?: DayLockOrderByWithRelationInput | DayLockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DayLocks.
     */
    cursor?: DayLockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DayLocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DayLocks.
     */
    skip?: number
    distinct?: DayLockScalarFieldEnum | DayLockScalarFieldEnum[]
  }

  /**
   * DayLock create
   */
  export type DayLockCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DayLock
     */
    select?: DayLockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DayLock
     */
    omit?: DayLockOmit<ExtArgs> | null
    /**
     * The data needed to create a DayLock.
     */
    data: XOR<DayLockCreateInput, DayLockUncheckedCreateInput>
  }

  /**
   * DayLock createMany
   */
  export type DayLockCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DayLocks.
     */
    data: DayLockCreateManyInput | DayLockCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DayLock createManyAndReturn
   */
  export type DayLockCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DayLock
     */
    select?: DayLockSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DayLock
     */
    omit?: DayLockOmit<ExtArgs> | null
    /**
     * The data used to create many DayLocks.
     */
    data: DayLockCreateManyInput | DayLockCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DayLock update
   */
  export type DayLockUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DayLock
     */
    select?: DayLockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DayLock
     */
    omit?: DayLockOmit<ExtArgs> | null
    /**
     * The data needed to update a DayLock.
     */
    data: XOR<DayLockUpdateInput, DayLockUncheckedUpdateInput>
    /**
     * Choose, which DayLock to update.
     */
    where: DayLockWhereUniqueInput
  }

  /**
   * DayLock updateMany
   */
  export type DayLockUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DayLocks.
     */
    data: XOR<DayLockUpdateManyMutationInput, DayLockUncheckedUpdateManyInput>
    /**
     * Filter which DayLocks to update
     */
    where?: DayLockWhereInput
    /**
     * Limit how many DayLocks to update.
     */
    limit?: number
  }

  /**
   * DayLock updateManyAndReturn
   */
  export type DayLockUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DayLock
     */
    select?: DayLockSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DayLock
     */
    omit?: DayLockOmit<ExtArgs> | null
    /**
     * The data used to update DayLocks.
     */
    data: XOR<DayLockUpdateManyMutationInput, DayLockUncheckedUpdateManyInput>
    /**
     * Filter which DayLocks to update
     */
    where?: DayLockWhereInput
    /**
     * Limit how many DayLocks to update.
     */
    limit?: number
  }

  /**
   * DayLock upsert
   */
  export type DayLockUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DayLock
     */
    select?: DayLockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DayLock
     */
    omit?: DayLockOmit<ExtArgs> | null
    /**
     * The filter to search for the DayLock to update in case it exists.
     */
    where: DayLockWhereUniqueInput
    /**
     * In case the DayLock found by the `where` argument doesn't exist, create a new DayLock with this data.
     */
    create: XOR<DayLockCreateInput, DayLockUncheckedCreateInput>
    /**
     * In case the DayLock was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DayLockUpdateInput, DayLockUncheckedUpdateInput>
  }

  /**
   * DayLock delete
   */
  export type DayLockDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DayLock
     */
    select?: DayLockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DayLock
     */
    omit?: DayLockOmit<ExtArgs> | null
    /**
     * Filter which DayLock to delete.
     */
    where: DayLockWhereUniqueInput
  }

  /**
   * DayLock deleteMany
   */
  export type DayLockDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DayLocks to delete
     */
    where?: DayLockWhereInput
    /**
     * Limit how many DayLocks to delete.
     */
    limit?: number
  }

  /**
   * DayLock without action
   */
  export type DayLockDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DayLock
     */
    select?: DayLockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DayLock
     */
    omit?: DayLockOmit<ExtArgs> | null
  }


  /**
   * Model PayPeriod
   */

  export type AggregatePayPeriod = {
    _count: PayPeriodCountAggregateOutputType | null
    _min: PayPeriodMinAggregateOutputType | null
    _max: PayPeriodMaxAggregateOutputType | null
  }

  export type PayPeriodMinAggregateOutputType = {
    id: string | null
    startDate: Date | null
    endDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    salaryMonth: string | null
  }

  export type PayPeriodMaxAggregateOutputType = {
    id: string | null
    startDate: Date | null
    endDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    salaryMonth: string | null
  }

  export type PayPeriodCountAggregateOutputType = {
    id: number
    startDate: number
    endDate: number
    createdAt: number
    updatedAt: number
    salaryMonth: number
    _all: number
  }


  export type PayPeriodMinAggregateInputType = {
    id?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
    salaryMonth?: true
  }

  export type PayPeriodMaxAggregateInputType = {
    id?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
    salaryMonth?: true
  }

  export type PayPeriodCountAggregateInputType = {
    id?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
    salaryMonth?: true
    _all?: true
  }

  export type PayPeriodAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PayPeriod to aggregate.
     */
    where?: PayPeriodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PayPeriods to fetch.
     */
    orderBy?: PayPeriodOrderByWithRelationInput | PayPeriodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PayPeriodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PayPeriods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PayPeriods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PayPeriods
    **/
    _count?: true | PayPeriodCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PayPeriodMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PayPeriodMaxAggregateInputType
  }

  export type GetPayPeriodAggregateType<T extends PayPeriodAggregateArgs> = {
        [P in keyof T & keyof AggregatePayPeriod]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayPeriod[P]>
      : GetScalarType<T[P], AggregatePayPeriod[P]>
  }




  export type PayPeriodGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PayPeriodWhereInput
    orderBy?: PayPeriodOrderByWithAggregationInput | PayPeriodOrderByWithAggregationInput[]
    by: PayPeriodScalarFieldEnum[] | PayPeriodScalarFieldEnum
    having?: PayPeriodScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PayPeriodCountAggregateInputType | true
    _min?: PayPeriodMinAggregateInputType
    _max?: PayPeriodMaxAggregateInputType
  }

  export type PayPeriodGroupByOutputType = {
    id: string
    startDate: Date
    endDate: Date
    createdAt: Date
    updatedAt: Date
    salaryMonth: string
    _count: PayPeriodCountAggregateOutputType | null
    _min: PayPeriodMinAggregateOutputType | null
    _max: PayPeriodMaxAggregateOutputType | null
  }

  type GetPayPeriodGroupByPayload<T extends PayPeriodGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PayPeriodGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PayPeriodGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PayPeriodGroupByOutputType[P]>
            : GetScalarType<T[P], PayPeriodGroupByOutputType[P]>
        }
      >
    >


  export type PayPeriodSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    salaryMonth?: boolean
  }, ExtArgs["result"]["payPeriod"]>

  export type PayPeriodSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    salaryMonth?: boolean
  }, ExtArgs["result"]["payPeriod"]>

  export type PayPeriodSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    salaryMonth?: boolean
  }, ExtArgs["result"]["payPeriod"]>

  export type PayPeriodSelectScalar = {
    id?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    salaryMonth?: boolean
  }

  export type PayPeriodOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "startDate" | "endDate" | "createdAt" | "updatedAt" | "salaryMonth", ExtArgs["result"]["payPeriod"]>

  export type $PayPeriodPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PayPeriod"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      startDate: Date
      endDate: Date
      createdAt: Date
      updatedAt: Date
      salaryMonth: string
    }, ExtArgs["result"]["payPeriod"]>
    composites: {}
  }

  type PayPeriodGetPayload<S extends boolean | null | undefined | PayPeriodDefaultArgs> = $Result.GetResult<Prisma.$PayPeriodPayload, S>

  type PayPeriodCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PayPeriodFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PayPeriodCountAggregateInputType | true
    }

  export interface PayPeriodDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PayPeriod'], meta: { name: 'PayPeriod' } }
    /**
     * Find zero or one PayPeriod that matches the filter.
     * @param {PayPeriodFindUniqueArgs} args - Arguments to find a PayPeriod
     * @example
     * // Get one PayPeriod
     * const payPeriod = await prisma.payPeriod.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PayPeriodFindUniqueArgs>(args: SelectSubset<T, PayPeriodFindUniqueArgs<ExtArgs>>): Prisma__PayPeriodClient<$Result.GetResult<Prisma.$PayPeriodPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PayPeriod that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PayPeriodFindUniqueOrThrowArgs} args - Arguments to find a PayPeriod
     * @example
     * // Get one PayPeriod
     * const payPeriod = await prisma.payPeriod.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PayPeriodFindUniqueOrThrowArgs>(args: SelectSubset<T, PayPeriodFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PayPeriodClient<$Result.GetResult<Prisma.$PayPeriodPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PayPeriod that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayPeriodFindFirstArgs} args - Arguments to find a PayPeriod
     * @example
     * // Get one PayPeriod
     * const payPeriod = await prisma.payPeriod.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PayPeriodFindFirstArgs>(args?: SelectSubset<T, PayPeriodFindFirstArgs<ExtArgs>>): Prisma__PayPeriodClient<$Result.GetResult<Prisma.$PayPeriodPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PayPeriod that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayPeriodFindFirstOrThrowArgs} args - Arguments to find a PayPeriod
     * @example
     * // Get one PayPeriod
     * const payPeriod = await prisma.payPeriod.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PayPeriodFindFirstOrThrowArgs>(args?: SelectSubset<T, PayPeriodFindFirstOrThrowArgs<ExtArgs>>): Prisma__PayPeriodClient<$Result.GetResult<Prisma.$PayPeriodPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PayPeriods that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayPeriodFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PayPeriods
     * const payPeriods = await prisma.payPeriod.findMany()
     * 
     * // Get first 10 PayPeriods
     * const payPeriods = await prisma.payPeriod.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const payPeriodWithIdOnly = await prisma.payPeriod.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PayPeriodFindManyArgs>(args?: SelectSubset<T, PayPeriodFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PayPeriodPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PayPeriod.
     * @param {PayPeriodCreateArgs} args - Arguments to create a PayPeriod.
     * @example
     * // Create one PayPeriod
     * const PayPeriod = await prisma.payPeriod.create({
     *   data: {
     *     // ... data to create a PayPeriod
     *   }
     * })
     * 
     */
    create<T extends PayPeriodCreateArgs>(args: SelectSubset<T, PayPeriodCreateArgs<ExtArgs>>): Prisma__PayPeriodClient<$Result.GetResult<Prisma.$PayPeriodPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PayPeriods.
     * @param {PayPeriodCreateManyArgs} args - Arguments to create many PayPeriods.
     * @example
     * // Create many PayPeriods
     * const payPeriod = await prisma.payPeriod.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PayPeriodCreateManyArgs>(args?: SelectSubset<T, PayPeriodCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PayPeriods and returns the data saved in the database.
     * @param {PayPeriodCreateManyAndReturnArgs} args - Arguments to create many PayPeriods.
     * @example
     * // Create many PayPeriods
     * const payPeriod = await prisma.payPeriod.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PayPeriods and only return the `id`
     * const payPeriodWithIdOnly = await prisma.payPeriod.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PayPeriodCreateManyAndReturnArgs>(args?: SelectSubset<T, PayPeriodCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PayPeriodPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PayPeriod.
     * @param {PayPeriodDeleteArgs} args - Arguments to delete one PayPeriod.
     * @example
     * // Delete one PayPeriod
     * const PayPeriod = await prisma.payPeriod.delete({
     *   where: {
     *     // ... filter to delete one PayPeriod
     *   }
     * })
     * 
     */
    delete<T extends PayPeriodDeleteArgs>(args: SelectSubset<T, PayPeriodDeleteArgs<ExtArgs>>): Prisma__PayPeriodClient<$Result.GetResult<Prisma.$PayPeriodPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PayPeriod.
     * @param {PayPeriodUpdateArgs} args - Arguments to update one PayPeriod.
     * @example
     * // Update one PayPeriod
     * const payPeriod = await prisma.payPeriod.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PayPeriodUpdateArgs>(args: SelectSubset<T, PayPeriodUpdateArgs<ExtArgs>>): Prisma__PayPeriodClient<$Result.GetResult<Prisma.$PayPeriodPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PayPeriods.
     * @param {PayPeriodDeleteManyArgs} args - Arguments to filter PayPeriods to delete.
     * @example
     * // Delete a few PayPeriods
     * const { count } = await prisma.payPeriod.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PayPeriodDeleteManyArgs>(args?: SelectSubset<T, PayPeriodDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PayPeriods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayPeriodUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PayPeriods
     * const payPeriod = await prisma.payPeriod.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PayPeriodUpdateManyArgs>(args: SelectSubset<T, PayPeriodUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PayPeriods and returns the data updated in the database.
     * @param {PayPeriodUpdateManyAndReturnArgs} args - Arguments to update many PayPeriods.
     * @example
     * // Update many PayPeriods
     * const payPeriod = await prisma.payPeriod.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PayPeriods and only return the `id`
     * const payPeriodWithIdOnly = await prisma.payPeriod.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PayPeriodUpdateManyAndReturnArgs>(args: SelectSubset<T, PayPeriodUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PayPeriodPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PayPeriod.
     * @param {PayPeriodUpsertArgs} args - Arguments to update or create a PayPeriod.
     * @example
     * // Update or create a PayPeriod
     * const payPeriod = await prisma.payPeriod.upsert({
     *   create: {
     *     // ... data to create a PayPeriod
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PayPeriod we want to update
     *   }
     * })
     */
    upsert<T extends PayPeriodUpsertArgs>(args: SelectSubset<T, PayPeriodUpsertArgs<ExtArgs>>): Prisma__PayPeriodClient<$Result.GetResult<Prisma.$PayPeriodPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PayPeriods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayPeriodCountArgs} args - Arguments to filter PayPeriods to count.
     * @example
     * // Count the number of PayPeriods
     * const count = await prisma.payPeriod.count({
     *   where: {
     *     // ... the filter for the PayPeriods we want to count
     *   }
     * })
    **/
    count<T extends PayPeriodCountArgs>(
      args?: Subset<T, PayPeriodCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PayPeriodCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PayPeriod.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayPeriodAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PayPeriodAggregateArgs>(args: Subset<T, PayPeriodAggregateArgs>): Prisma.PrismaPromise<GetPayPeriodAggregateType<T>>

    /**
     * Group by PayPeriod.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayPeriodGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PayPeriodGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PayPeriodGroupByArgs['orderBy'] }
        : { orderBy?: PayPeriodGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PayPeriodGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPayPeriodGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PayPeriod model
   */
  readonly fields: PayPeriodFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PayPeriod.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PayPeriodClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PayPeriod model
   */ 
  interface PayPeriodFieldRefs {
    readonly id: FieldRef<"PayPeriod", 'String'>
    readonly startDate: FieldRef<"PayPeriod", 'DateTime'>
    readonly endDate: FieldRef<"PayPeriod", 'DateTime'>
    readonly createdAt: FieldRef<"PayPeriod", 'DateTime'>
    readonly updatedAt: FieldRef<"PayPeriod", 'DateTime'>
    readonly salaryMonth: FieldRef<"PayPeriod", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PayPeriod findUnique
   */
  export type PayPeriodFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayPeriod
     */
    select?: PayPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayPeriod
     */
    omit?: PayPeriodOmit<ExtArgs> | null
    /**
     * Filter, which PayPeriod to fetch.
     */
    where: PayPeriodWhereUniqueInput
  }

  /**
   * PayPeriod findUniqueOrThrow
   */
  export type PayPeriodFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayPeriod
     */
    select?: PayPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayPeriod
     */
    omit?: PayPeriodOmit<ExtArgs> | null
    /**
     * Filter, which PayPeriod to fetch.
     */
    where: PayPeriodWhereUniqueInput
  }

  /**
   * PayPeriod findFirst
   */
  export type PayPeriodFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayPeriod
     */
    select?: PayPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayPeriod
     */
    omit?: PayPeriodOmit<ExtArgs> | null
    /**
     * Filter, which PayPeriod to fetch.
     */
    where?: PayPeriodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PayPeriods to fetch.
     */
    orderBy?: PayPeriodOrderByWithRelationInput | PayPeriodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PayPeriods.
     */
    cursor?: PayPeriodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PayPeriods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PayPeriods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PayPeriods.
     */
    distinct?: PayPeriodScalarFieldEnum | PayPeriodScalarFieldEnum[]
  }

  /**
   * PayPeriod findFirstOrThrow
   */
  export type PayPeriodFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayPeriod
     */
    select?: PayPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayPeriod
     */
    omit?: PayPeriodOmit<ExtArgs> | null
    /**
     * Filter, which PayPeriod to fetch.
     */
    where?: PayPeriodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PayPeriods to fetch.
     */
    orderBy?: PayPeriodOrderByWithRelationInput | PayPeriodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PayPeriods.
     */
    cursor?: PayPeriodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PayPeriods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PayPeriods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PayPeriods.
     */
    distinct?: PayPeriodScalarFieldEnum | PayPeriodScalarFieldEnum[]
  }

  /**
   * PayPeriod findMany
   */
  export type PayPeriodFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayPeriod
     */
    select?: PayPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayPeriod
     */
    omit?: PayPeriodOmit<ExtArgs> | null
    /**
     * Filter, which PayPeriods to fetch.
     */
    where?: PayPeriodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PayPeriods to fetch.
     */
    orderBy?: PayPeriodOrderByWithRelationInput | PayPeriodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PayPeriods.
     */
    cursor?: PayPeriodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PayPeriods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PayPeriods.
     */
    skip?: number
    distinct?: PayPeriodScalarFieldEnum | PayPeriodScalarFieldEnum[]
  }

  /**
   * PayPeriod create
   */
  export type PayPeriodCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayPeriod
     */
    select?: PayPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayPeriod
     */
    omit?: PayPeriodOmit<ExtArgs> | null
    /**
     * The data needed to create a PayPeriod.
     */
    data: XOR<PayPeriodCreateInput, PayPeriodUncheckedCreateInput>
  }

  /**
   * PayPeriod createMany
   */
  export type PayPeriodCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PayPeriods.
     */
    data: PayPeriodCreateManyInput | PayPeriodCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PayPeriod createManyAndReturn
   */
  export type PayPeriodCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayPeriod
     */
    select?: PayPeriodSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PayPeriod
     */
    omit?: PayPeriodOmit<ExtArgs> | null
    /**
     * The data used to create many PayPeriods.
     */
    data: PayPeriodCreateManyInput | PayPeriodCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PayPeriod update
   */
  export type PayPeriodUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayPeriod
     */
    select?: PayPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayPeriod
     */
    omit?: PayPeriodOmit<ExtArgs> | null
    /**
     * The data needed to update a PayPeriod.
     */
    data: XOR<PayPeriodUpdateInput, PayPeriodUncheckedUpdateInput>
    /**
     * Choose, which PayPeriod to update.
     */
    where: PayPeriodWhereUniqueInput
  }

  /**
   * PayPeriod updateMany
   */
  export type PayPeriodUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PayPeriods.
     */
    data: XOR<PayPeriodUpdateManyMutationInput, PayPeriodUncheckedUpdateManyInput>
    /**
     * Filter which PayPeriods to update
     */
    where?: PayPeriodWhereInput
    /**
     * Limit how many PayPeriods to update.
     */
    limit?: number
  }

  /**
   * PayPeriod updateManyAndReturn
   */
  export type PayPeriodUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayPeriod
     */
    select?: PayPeriodSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PayPeriod
     */
    omit?: PayPeriodOmit<ExtArgs> | null
    /**
     * The data used to update PayPeriods.
     */
    data: XOR<PayPeriodUpdateManyMutationInput, PayPeriodUncheckedUpdateManyInput>
    /**
     * Filter which PayPeriods to update
     */
    where?: PayPeriodWhereInput
    /**
     * Limit how many PayPeriods to update.
     */
    limit?: number
  }

  /**
   * PayPeriod upsert
   */
  export type PayPeriodUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayPeriod
     */
    select?: PayPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayPeriod
     */
    omit?: PayPeriodOmit<ExtArgs> | null
    /**
     * The filter to search for the PayPeriod to update in case it exists.
     */
    where: PayPeriodWhereUniqueInput
    /**
     * In case the PayPeriod found by the `where` argument doesn't exist, create a new PayPeriod with this data.
     */
    create: XOR<PayPeriodCreateInput, PayPeriodUncheckedCreateInput>
    /**
     * In case the PayPeriod was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PayPeriodUpdateInput, PayPeriodUncheckedUpdateInput>
  }

  /**
   * PayPeriod delete
   */
  export type PayPeriodDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayPeriod
     */
    select?: PayPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayPeriod
     */
    omit?: PayPeriodOmit<ExtArgs> | null
    /**
     * Filter which PayPeriod to delete.
     */
    where: PayPeriodWhereUniqueInput
  }

  /**
   * PayPeriod deleteMany
   */
  export type PayPeriodDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PayPeriods to delete
     */
    where?: PayPeriodWhereInput
    /**
     * Limit how many PayPeriods to delete.
     */
    limit?: number
  }

  /**
   * PayPeriod without action
   */
  export type PayPeriodDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayPeriod
     */
    select?: PayPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayPeriod
     */
    omit?: PayPeriodOmit<ExtArgs> | null
  }


  /**
   * Model Amendment
   */

  export type AggregateAmendment = {
    _count: AmendmentCountAggregateOutputType | null
    _avg: AmendmentAvgAggregateOutputType | null
    _sum: AmendmentSumAggregateOutputType | null
    _min: AmendmentMinAggregateOutputType | null
    _max: AmendmentMaxAggregateOutputType | null
  }

  export type AmendmentAvgAggregateOutputType = {
    newHoursPerWeek: number | null
  }

  export type AmendmentSumAggregateOutputType = {
    newHoursPerWeek: number | null
  }

  export type AmendmentMinAggregateOutputType = {
    id: string | null
    contractId: string | null
    startDate: Date | null
    endDate: Date | null
    newHoursPerWeek: number | null
    isTemporary: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AmendmentMaxAggregateOutputType = {
    id: string | null
    contractId: string | null
    startDate: Date | null
    endDate: Date | null
    newHoursPerWeek: number | null
    isTemporary: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AmendmentCountAggregateOutputType = {
    id: number
    contractId: number
    startDate: number
    endDate: number
    newHoursPerWeek: number
    isTemporary: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AmendmentAvgAggregateInputType = {
    newHoursPerWeek?: true
  }

  export type AmendmentSumAggregateInputType = {
    newHoursPerWeek?: true
  }

  export type AmendmentMinAggregateInputType = {
    id?: true
    contractId?: true
    startDate?: true
    endDate?: true
    newHoursPerWeek?: true
    isTemporary?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AmendmentMaxAggregateInputType = {
    id?: true
    contractId?: true
    startDate?: true
    endDate?: true
    newHoursPerWeek?: true
    isTemporary?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AmendmentCountAggregateInputType = {
    id?: true
    contractId?: true
    startDate?: true
    endDate?: true
    newHoursPerWeek?: true
    isTemporary?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AmendmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Amendment to aggregate.
     */
    where?: AmendmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Amendments to fetch.
     */
    orderBy?: AmendmentOrderByWithRelationInput | AmendmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AmendmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Amendments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Amendments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Amendments
    **/
    _count?: true | AmendmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AmendmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AmendmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AmendmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AmendmentMaxAggregateInputType
  }

  export type GetAmendmentAggregateType<T extends AmendmentAggregateArgs> = {
        [P in keyof T & keyof AggregateAmendment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAmendment[P]>
      : GetScalarType<T[P], AggregateAmendment[P]>
  }




  export type AmendmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AmendmentWhereInput
    orderBy?: AmendmentOrderByWithAggregationInput | AmendmentOrderByWithAggregationInput[]
    by: AmendmentScalarFieldEnum[] | AmendmentScalarFieldEnum
    having?: AmendmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AmendmentCountAggregateInputType | true
    _avg?: AmendmentAvgAggregateInputType
    _sum?: AmendmentSumAggregateInputType
    _min?: AmendmentMinAggregateInputType
    _max?: AmendmentMaxAggregateInputType
  }

  export type AmendmentGroupByOutputType = {
    id: string
    contractId: string
    startDate: Date
    endDate: Date | null
    newHoursPerWeek: number | null
    isTemporary: boolean
    createdAt: Date
    updatedAt: Date
    _count: AmendmentCountAggregateOutputType | null
    _avg: AmendmentAvgAggregateOutputType | null
    _sum: AmendmentSumAggregateOutputType | null
    _min: AmendmentMinAggregateOutputType | null
    _max: AmendmentMaxAggregateOutputType | null
  }

  type GetAmendmentGroupByPayload<T extends AmendmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AmendmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AmendmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AmendmentGroupByOutputType[P]>
            : GetScalarType<T[P], AmendmentGroupByOutputType[P]>
        }
      >
    >


  export type AmendmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contractId?: boolean
    startDate?: boolean
    endDate?: boolean
    newHoursPerWeek?: boolean
    isTemporary?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    contract?: boolean | ContractDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["amendment"]>

  export type AmendmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contractId?: boolean
    startDate?: boolean
    endDate?: boolean
    newHoursPerWeek?: boolean
    isTemporary?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    contract?: boolean | ContractDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["amendment"]>

  export type AmendmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contractId?: boolean
    startDate?: boolean
    endDate?: boolean
    newHoursPerWeek?: boolean
    isTemporary?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    contract?: boolean | ContractDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["amendment"]>

  export type AmendmentSelectScalar = {
    id?: boolean
    contractId?: boolean
    startDate?: boolean
    endDate?: boolean
    newHoursPerWeek?: boolean
    isTemporary?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AmendmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "contractId" | "startDate" | "endDate" | "newHoursPerWeek" | "isTemporary" | "createdAt" | "updatedAt", ExtArgs["result"]["amendment"]>
  export type AmendmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contract?: boolean | ContractDefaultArgs<ExtArgs>
  }
  export type AmendmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contract?: boolean | ContractDefaultArgs<ExtArgs>
  }
  export type AmendmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contract?: boolean | ContractDefaultArgs<ExtArgs>
  }

  export type $AmendmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Amendment"
    objects: {
      contract: Prisma.$ContractPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      contractId: string
      startDate: Date
      endDate: Date | null
      newHoursPerWeek: number | null
      isTemporary: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["amendment"]>
    composites: {}
  }

  type AmendmentGetPayload<S extends boolean | null | undefined | AmendmentDefaultArgs> = $Result.GetResult<Prisma.$AmendmentPayload, S>

  type AmendmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AmendmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AmendmentCountAggregateInputType | true
    }

  export interface AmendmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Amendment'], meta: { name: 'Amendment' } }
    /**
     * Find zero or one Amendment that matches the filter.
     * @param {AmendmentFindUniqueArgs} args - Arguments to find a Amendment
     * @example
     * // Get one Amendment
     * const amendment = await prisma.amendment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AmendmentFindUniqueArgs>(args: SelectSubset<T, AmendmentFindUniqueArgs<ExtArgs>>): Prisma__AmendmentClient<$Result.GetResult<Prisma.$AmendmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Amendment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AmendmentFindUniqueOrThrowArgs} args - Arguments to find a Amendment
     * @example
     * // Get one Amendment
     * const amendment = await prisma.amendment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AmendmentFindUniqueOrThrowArgs>(args: SelectSubset<T, AmendmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AmendmentClient<$Result.GetResult<Prisma.$AmendmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Amendment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmendmentFindFirstArgs} args - Arguments to find a Amendment
     * @example
     * // Get one Amendment
     * const amendment = await prisma.amendment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AmendmentFindFirstArgs>(args?: SelectSubset<T, AmendmentFindFirstArgs<ExtArgs>>): Prisma__AmendmentClient<$Result.GetResult<Prisma.$AmendmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Amendment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmendmentFindFirstOrThrowArgs} args - Arguments to find a Amendment
     * @example
     * // Get one Amendment
     * const amendment = await prisma.amendment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AmendmentFindFirstOrThrowArgs>(args?: SelectSubset<T, AmendmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__AmendmentClient<$Result.GetResult<Prisma.$AmendmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Amendments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmendmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Amendments
     * const amendments = await prisma.amendment.findMany()
     * 
     * // Get first 10 Amendments
     * const amendments = await prisma.amendment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const amendmentWithIdOnly = await prisma.amendment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AmendmentFindManyArgs>(args?: SelectSubset<T, AmendmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AmendmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Amendment.
     * @param {AmendmentCreateArgs} args - Arguments to create a Amendment.
     * @example
     * // Create one Amendment
     * const Amendment = await prisma.amendment.create({
     *   data: {
     *     // ... data to create a Amendment
     *   }
     * })
     * 
     */
    create<T extends AmendmentCreateArgs>(args: SelectSubset<T, AmendmentCreateArgs<ExtArgs>>): Prisma__AmendmentClient<$Result.GetResult<Prisma.$AmendmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Amendments.
     * @param {AmendmentCreateManyArgs} args - Arguments to create many Amendments.
     * @example
     * // Create many Amendments
     * const amendment = await prisma.amendment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AmendmentCreateManyArgs>(args?: SelectSubset<T, AmendmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Amendments and returns the data saved in the database.
     * @param {AmendmentCreateManyAndReturnArgs} args - Arguments to create many Amendments.
     * @example
     * // Create many Amendments
     * const amendment = await prisma.amendment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Amendments and only return the `id`
     * const amendmentWithIdOnly = await prisma.amendment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AmendmentCreateManyAndReturnArgs>(args?: SelectSubset<T, AmendmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AmendmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Amendment.
     * @param {AmendmentDeleteArgs} args - Arguments to delete one Amendment.
     * @example
     * // Delete one Amendment
     * const Amendment = await prisma.amendment.delete({
     *   where: {
     *     // ... filter to delete one Amendment
     *   }
     * })
     * 
     */
    delete<T extends AmendmentDeleteArgs>(args: SelectSubset<T, AmendmentDeleteArgs<ExtArgs>>): Prisma__AmendmentClient<$Result.GetResult<Prisma.$AmendmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Amendment.
     * @param {AmendmentUpdateArgs} args - Arguments to update one Amendment.
     * @example
     * // Update one Amendment
     * const amendment = await prisma.amendment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AmendmentUpdateArgs>(args: SelectSubset<T, AmendmentUpdateArgs<ExtArgs>>): Prisma__AmendmentClient<$Result.GetResult<Prisma.$AmendmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Amendments.
     * @param {AmendmentDeleteManyArgs} args - Arguments to filter Amendments to delete.
     * @example
     * // Delete a few Amendments
     * const { count } = await prisma.amendment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AmendmentDeleteManyArgs>(args?: SelectSubset<T, AmendmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Amendments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmendmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Amendments
     * const amendment = await prisma.amendment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AmendmentUpdateManyArgs>(args: SelectSubset<T, AmendmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Amendments and returns the data updated in the database.
     * @param {AmendmentUpdateManyAndReturnArgs} args - Arguments to update many Amendments.
     * @example
     * // Update many Amendments
     * const amendment = await prisma.amendment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Amendments and only return the `id`
     * const amendmentWithIdOnly = await prisma.amendment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AmendmentUpdateManyAndReturnArgs>(args: SelectSubset<T, AmendmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AmendmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Amendment.
     * @param {AmendmentUpsertArgs} args - Arguments to update or create a Amendment.
     * @example
     * // Update or create a Amendment
     * const amendment = await prisma.amendment.upsert({
     *   create: {
     *     // ... data to create a Amendment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Amendment we want to update
     *   }
     * })
     */
    upsert<T extends AmendmentUpsertArgs>(args: SelectSubset<T, AmendmentUpsertArgs<ExtArgs>>): Prisma__AmendmentClient<$Result.GetResult<Prisma.$AmendmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Amendments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmendmentCountArgs} args - Arguments to filter Amendments to count.
     * @example
     * // Count the number of Amendments
     * const count = await prisma.amendment.count({
     *   where: {
     *     // ... the filter for the Amendments we want to count
     *   }
     * })
    **/
    count<T extends AmendmentCountArgs>(
      args?: Subset<T, AmendmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AmendmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Amendment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmendmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AmendmentAggregateArgs>(args: Subset<T, AmendmentAggregateArgs>): Prisma.PrismaPromise<GetAmendmentAggregateType<T>>

    /**
     * Group by Amendment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmendmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AmendmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AmendmentGroupByArgs['orderBy'] }
        : { orderBy?: AmendmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AmendmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAmendmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Amendment model
   */
  readonly fields: AmendmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Amendment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AmendmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    contract<T extends ContractDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContractDefaultArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Amendment model
   */ 
  interface AmendmentFieldRefs {
    readonly id: FieldRef<"Amendment", 'String'>
    readonly contractId: FieldRef<"Amendment", 'String'>
    readonly startDate: FieldRef<"Amendment", 'DateTime'>
    readonly endDate: FieldRef<"Amendment", 'DateTime'>
    readonly newHoursPerWeek: FieldRef<"Amendment", 'Int'>
    readonly isTemporary: FieldRef<"Amendment", 'Boolean'>
    readonly createdAt: FieldRef<"Amendment", 'DateTime'>
    readonly updatedAt: FieldRef<"Amendment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Amendment findUnique
   */
  export type AmendmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amendment
     */
    select?: AmendmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Amendment
     */
    omit?: AmendmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmendmentInclude<ExtArgs> | null
    /**
     * Filter, which Amendment to fetch.
     */
    where: AmendmentWhereUniqueInput
  }

  /**
   * Amendment findUniqueOrThrow
   */
  export type AmendmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amendment
     */
    select?: AmendmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Amendment
     */
    omit?: AmendmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmendmentInclude<ExtArgs> | null
    /**
     * Filter, which Amendment to fetch.
     */
    where: AmendmentWhereUniqueInput
  }

  /**
   * Amendment findFirst
   */
  export type AmendmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amendment
     */
    select?: AmendmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Amendment
     */
    omit?: AmendmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmendmentInclude<ExtArgs> | null
    /**
     * Filter, which Amendment to fetch.
     */
    where?: AmendmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Amendments to fetch.
     */
    orderBy?: AmendmentOrderByWithRelationInput | AmendmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Amendments.
     */
    cursor?: AmendmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Amendments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Amendments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Amendments.
     */
    distinct?: AmendmentScalarFieldEnum | AmendmentScalarFieldEnum[]
  }

  /**
   * Amendment findFirstOrThrow
   */
  export type AmendmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amendment
     */
    select?: AmendmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Amendment
     */
    omit?: AmendmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmendmentInclude<ExtArgs> | null
    /**
     * Filter, which Amendment to fetch.
     */
    where?: AmendmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Amendments to fetch.
     */
    orderBy?: AmendmentOrderByWithRelationInput | AmendmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Amendments.
     */
    cursor?: AmendmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Amendments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Amendments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Amendments.
     */
    distinct?: AmendmentScalarFieldEnum | AmendmentScalarFieldEnum[]
  }

  /**
   * Amendment findMany
   */
  export type AmendmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amendment
     */
    select?: AmendmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Amendment
     */
    omit?: AmendmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmendmentInclude<ExtArgs> | null
    /**
     * Filter, which Amendments to fetch.
     */
    where?: AmendmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Amendments to fetch.
     */
    orderBy?: AmendmentOrderByWithRelationInput | AmendmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Amendments.
     */
    cursor?: AmendmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Amendments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Amendments.
     */
    skip?: number
    distinct?: AmendmentScalarFieldEnum | AmendmentScalarFieldEnum[]
  }

  /**
   * Amendment create
   */
  export type AmendmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amendment
     */
    select?: AmendmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Amendment
     */
    omit?: AmendmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmendmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Amendment.
     */
    data: XOR<AmendmentCreateInput, AmendmentUncheckedCreateInput>
  }

  /**
   * Amendment createMany
   */
  export type AmendmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Amendments.
     */
    data: AmendmentCreateManyInput | AmendmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Amendment createManyAndReturn
   */
  export type AmendmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amendment
     */
    select?: AmendmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Amendment
     */
    omit?: AmendmentOmit<ExtArgs> | null
    /**
     * The data used to create many Amendments.
     */
    data: AmendmentCreateManyInput | AmendmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmendmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Amendment update
   */
  export type AmendmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amendment
     */
    select?: AmendmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Amendment
     */
    omit?: AmendmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmendmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Amendment.
     */
    data: XOR<AmendmentUpdateInput, AmendmentUncheckedUpdateInput>
    /**
     * Choose, which Amendment to update.
     */
    where: AmendmentWhereUniqueInput
  }

  /**
   * Amendment updateMany
   */
  export type AmendmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Amendments.
     */
    data: XOR<AmendmentUpdateManyMutationInput, AmendmentUncheckedUpdateManyInput>
    /**
     * Filter which Amendments to update
     */
    where?: AmendmentWhereInput
    /**
     * Limit how many Amendments to update.
     */
    limit?: number
  }

  /**
   * Amendment updateManyAndReturn
   */
  export type AmendmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amendment
     */
    select?: AmendmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Amendment
     */
    omit?: AmendmentOmit<ExtArgs> | null
    /**
     * The data used to update Amendments.
     */
    data: XOR<AmendmentUpdateManyMutationInput, AmendmentUncheckedUpdateManyInput>
    /**
     * Filter which Amendments to update
     */
    where?: AmendmentWhereInput
    /**
     * Limit how many Amendments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmendmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Amendment upsert
   */
  export type AmendmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amendment
     */
    select?: AmendmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Amendment
     */
    omit?: AmendmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmendmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Amendment to update in case it exists.
     */
    where: AmendmentWhereUniqueInput
    /**
     * In case the Amendment found by the `where` argument doesn't exist, create a new Amendment with this data.
     */
    create: XOR<AmendmentCreateInput, AmendmentUncheckedCreateInput>
    /**
     * In case the Amendment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AmendmentUpdateInput, AmendmentUncheckedUpdateInput>
  }

  /**
   * Amendment delete
   */
  export type AmendmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amendment
     */
    select?: AmendmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Amendment
     */
    omit?: AmendmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmendmentInclude<ExtArgs> | null
    /**
     * Filter which Amendment to delete.
     */
    where: AmendmentWhereUniqueInput
  }

  /**
   * Amendment deleteMany
   */
  export type AmendmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Amendments to delete
     */
    where?: AmendmentWhereInput
    /**
     * Limit how many Amendments to delete.
     */
    limit?: number
  }

  /**
   * Amendment without action
   */
  export type AmendmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amendment
     */
    select?: AmendmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Amendment
     */
    omit?: AmendmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmendmentInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const EmployeeScalarFieldEnum: {
    id: 'id',
    lastName: 'lastName',
    firstName: 'firstName',
    matricule: 'matricule',
    dateOfBirth: 'dateOfBirth',
    sex: 'sex',
    nationality: 'nationality',
    address: 'address',
    address2: 'address2',
    postalCode: 'postalCode',
    city: 'city',
    iban: 'iban',
    bic: 'bic',
    socialSecurityNumber: 'socialSecurityNumber',
    emergencyContactName: 'emergencyContactName',
    emergencyContactPhone: 'emergencyContactPhone',
    transportMeans: 'transportMeans',
    photoUrl: 'photoUrl',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EmployeeScalarFieldEnum = (typeof EmployeeScalarFieldEnum)[keyof typeof EmployeeScalarFieldEnum]


  export const ContractScalarFieldEnum: {
    id: 'id',
    contractType: 'contractType',
    role: 'role',
    hoursPerWeek: 'hoursPerWeek',
    status: 'status',
    resignationDate: 'resignationDate',
    endDate: 'endDate',
    employeeId: 'employeeId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ContractScalarFieldEnum = (typeof ContractScalarFieldEnum)[keyof typeof ContractScalarFieldEnum]


  export const AvailabilityIntervalScalarFieldEnum: {
    id: 'id',
    day: 'day',
    allDay: 'allDay',
    startTime: 'startTime',
    endTime: 'endTime',
    contractId: 'contractId'
  };

  export type AvailabilityIntervalScalarFieldEnum = (typeof AvailabilityIntervalScalarFieldEnum)[keyof typeof AvailabilityIntervalScalarFieldEnum]


  export const TimeRecordScalarFieldEnum: {
    id: 'id',
    date: 'date',
    checkIn: 'checkIn',
    checkOut: 'checkOut',
    employeeId: 'employeeId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TimeRecordScalarFieldEnum = (typeof TimeRecordScalarFieldEnum)[keyof typeof TimeRecordScalarFieldEnum]


  export const ShiftScalarFieldEnum: {
    id: 'id',
    date: 'date',
    startHour: 'startHour',
    endHour: 'endHour',
    shiftType: 'shiftType',
    employeeId: 'employeeId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ShiftScalarFieldEnum = (typeof ShiftScalarFieldEnum)[keyof typeof ShiftScalarFieldEnum]


  export const DayLockScalarFieldEnum: {
    id: 'id',
    date: 'date',
    locked: 'locked',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DayLockScalarFieldEnum = (typeof DayLockScalarFieldEnum)[keyof typeof DayLockScalarFieldEnum]


  export const PayPeriodScalarFieldEnum: {
    id: 'id',
    startDate: 'startDate',
    endDate: 'endDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    salaryMonth: 'salaryMonth'
  };

  export type PayPeriodScalarFieldEnum = (typeof PayPeriodScalarFieldEnum)[keyof typeof PayPeriodScalarFieldEnum]


  export const AmendmentScalarFieldEnum: {
    id: 'id',
    contractId: 'contractId',
    startDate: 'startDate',
    endDate: 'endDate',
    newHoursPerWeek: 'newHoursPerWeek',
    isTemporary: 'isTemporary',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AmendmentScalarFieldEnum = (typeof AmendmentScalarFieldEnum)[keyof typeof AmendmentScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Sex'
   */
  export type EnumSexFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Sex'>
    


  /**
   * Reference to a field of type 'Sex[]'
   */
  export type ListEnumSexFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Sex[]'>
    


  /**
   * Reference to a field of type 'ContractStatus'
   */
  export type EnumContractStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContractStatus'>
    


  /**
   * Reference to a field of type 'ContractStatus[]'
   */
  export type ListEnumContractStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContractStatus[]'>
    


  /**
   * Reference to a field of type 'DayOfWeek'
   */
  export type EnumDayOfWeekFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DayOfWeek'>
    


  /**
   * Reference to a field of type 'DayOfWeek[]'
   */
  export type ListEnumDayOfWeekFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DayOfWeek[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type EmployeeWhereInput = {
    AND?: EmployeeWhereInput | EmployeeWhereInput[]
    OR?: EmployeeWhereInput[]
    NOT?: EmployeeWhereInput | EmployeeWhereInput[]
    id?: StringFilter<"Employee"> | string
    lastName?: StringFilter<"Employee"> | string
    firstName?: StringFilter<"Employee"> | string
    matricule?: IntNullableFilter<"Employee"> | number | null
    dateOfBirth?: DateTimeNullableFilter<"Employee"> | Date | string | null
    sex?: EnumSexNullableFilter<"Employee"> | $Enums.Sex | null
    nationality?: StringNullableFilter<"Employee"> | string | null
    address?: StringNullableFilter<"Employee"> | string | null
    address2?: StringNullableFilter<"Employee"> | string | null
    postalCode?: StringNullableFilter<"Employee"> | string | null
    city?: StringNullableFilter<"Employee"> | string | null
    iban?: StringNullableFilter<"Employee"> | string | null
    bic?: StringNullableFilter<"Employee"> | string | null
    socialSecurityNumber?: StringNullableFilter<"Employee"> | string | null
    emergencyContactName?: StringNullableFilter<"Employee"> | string | null
    emergencyContactPhone?: StringNullableFilter<"Employee"> | string | null
    transportMeans?: StringNullableFilter<"Employee"> | string | null
    photoUrl?: StringNullableFilter<"Employee"> | string | null
    createdAt?: DateTimeFilter<"Employee"> | Date | string
    updatedAt?: DateTimeFilter<"Employee"> | Date | string
    contracts?: ContractListRelationFilter
    timeRecords?: TimeRecordListRelationFilter
    shifts?: ShiftListRelationFilter
  }

  export type EmployeeOrderByWithRelationInput = {
    id?: SortOrder
    lastName?: SortOrder
    firstName?: SortOrder
    matricule?: SortOrderInput | SortOrder
    dateOfBirth?: SortOrderInput | SortOrder
    sex?: SortOrderInput | SortOrder
    nationality?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    address2?: SortOrderInput | SortOrder
    postalCode?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    iban?: SortOrderInput | SortOrder
    bic?: SortOrderInput | SortOrder
    socialSecurityNumber?: SortOrderInput | SortOrder
    emergencyContactName?: SortOrderInput | SortOrder
    emergencyContactPhone?: SortOrderInput | SortOrder
    transportMeans?: SortOrderInput | SortOrder
    photoUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    contracts?: ContractOrderByRelationAggregateInput
    timeRecords?: TimeRecordOrderByRelationAggregateInput
    shifts?: ShiftOrderByRelationAggregateInput
  }

  export type EmployeeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    matricule?: number
    AND?: EmployeeWhereInput | EmployeeWhereInput[]
    OR?: EmployeeWhereInput[]
    NOT?: EmployeeWhereInput | EmployeeWhereInput[]
    lastName?: StringFilter<"Employee"> | string
    firstName?: StringFilter<"Employee"> | string
    dateOfBirth?: DateTimeNullableFilter<"Employee"> | Date | string | null
    sex?: EnumSexNullableFilter<"Employee"> | $Enums.Sex | null
    nationality?: StringNullableFilter<"Employee"> | string | null
    address?: StringNullableFilter<"Employee"> | string | null
    address2?: StringNullableFilter<"Employee"> | string | null
    postalCode?: StringNullableFilter<"Employee"> | string | null
    city?: StringNullableFilter<"Employee"> | string | null
    iban?: StringNullableFilter<"Employee"> | string | null
    bic?: StringNullableFilter<"Employee"> | string | null
    socialSecurityNumber?: StringNullableFilter<"Employee"> | string | null
    emergencyContactName?: StringNullableFilter<"Employee"> | string | null
    emergencyContactPhone?: StringNullableFilter<"Employee"> | string | null
    transportMeans?: StringNullableFilter<"Employee"> | string | null
    photoUrl?: StringNullableFilter<"Employee"> | string | null
    createdAt?: DateTimeFilter<"Employee"> | Date | string
    updatedAt?: DateTimeFilter<"Employee"> | Date | string
    contracts?: ContractListRelationFilter
    timeRecords?: TimeRecordListRelationFilter
    shifts?: ShiftListRelationFilter
  }, "id" | "matricule">

  export type EmployeeOrderByWithAggregationInput = {
    id?: SortOrder
    lastName?: SortOrder
    firstName?: SortOrder
    matricule?: SortOrderInput | SortOrder
    dateOfBirth?: SortOrderInput | SortOrder
    sex?: SortOrderInput | SortOrder
    nationality?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    address2?: SortOrderInput | SortOrder
    postalCode?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    iban?: SortOrderInput | SortOrder
    bic?: SortOrderInput | SortOrder
    socialSecurityNumber?: SortOrderInput | SortOrder
    emergencyContactName?: SortOrderInput | SortOrder
    emergencyContactPhone?: SortOrderInput | SortOrder
    transportMeans?: SortOrderInput | SortOrder
    photoUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EmployeeCountOrderByAggregateInput
    _avg?: EmployeeAvgOrderByAggregateInput
    _max?: EmployeeMaxOrderByAggregateInput
    _min?: EmployeeMinOrderByAggregateInput
    _sum?: EmployeeSumOrderByAggregateInput
  }

  export type EmployeeScalarWhereWithAggregatesInput = {
    AND?: EmployeeScalarWhereWithAggregatesInput | EmployeeScalarWhereWithAggregatesInput[]
    OR?: EmployeeScalarWhereWithAggregatesInput[]
    NOT?: EmployeeScalarWhereWithAggregatesInput | EmployeeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Employee"> | string
    lastName?: StringWithAggregatesFilter<"Employee"> | string
    firstName?: StringWithAggregatesFilter<"Employee"> | string
    matricule?: IntNullableWithAggregatesFilter<"Employee"> | number | null
    dateOfBirth?: DateTimeNullableWithAggregatesFilter<"Employee"> | Date | string | null
    sex?: EnumSexNullableWithAggregatesFilter<"Employee"> | $Enums.Sex | null
    nationality?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    address?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    address2?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    postalCode?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    city?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    iban?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    bic?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    socialSecurityNumber?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    emergencyContactName?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    emergencyContactPhone?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    transportMeans?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    photoUrl?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Employee"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Employee"> | Date | string
  }

  export type ContractWhereInput = {
    AND?: ContractWhereInput | ContractWhereInput[]
    OR?: ContractWhereInput[]
    NOT?: ContractWhereInput | ContractWhereInput[]
    id?: StringFilter<"Contract"> | string
    contractType?: StringNullableFilter<"Contract"> | string | null
    role?: StringNullableFilter<"Contract"> | string | null
    hoursPerWeek?: IntNullableFilter<"Contract"> | number | null
    status?: EnumContractStatusNullableFilter<"Contract"> | $Enums.ContractStatus | null
    resignationDate?: DateTimeNullableFilter<"Contract"> | Date | string | null
    endDate?: DateTimeNullableFilter<"Contract"> | Date | string | null
    employeeId?: StringFilter<"Contract"> | string
    createdAt?: DateTimeFilter<"Contract"> | Date | string
    updatedAt?: DateTimeFilter<"Contract"> | Date | string
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
    availability?: AvailabilityIntervalListRelationFilter
    amendments?: AmendmentListRelationFilter
  }

  export type ContractOrderByWithRelationInput = {
    id?: SortOrder
    contractType?: SortOrderInput | SortOrder
    role?: SortOrderInput | SortOrder
    hoursPerWeek?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    resignationDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    employeeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    employee?: EmployeeOrderByWithRelationInput
    availability?: AvailabilityIntervalOrderByRelationAggregateInput
    amendments?: AmendmentOrderByRelationAggregateInput
  }

  export type ContractWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ContractWhereInput | ContractWhereInput[]
    OR?: ContractWhereInput[]
    NOT?: ContractWhereInput | ContractWhereInput[]
    contractType?: StringNullableFilter<"Contract"> | string | null
    role?: StringNullableFilter<"Contract"> | string | null
    hoursPerWeek?: IntNullableFilter<"Contract"> | number | null
    status?: EnumContractStatusNullableFilter<"Contract"> | $Enums.ContractStatus | null
    resignationDate?: DateTimeNullableFilter<"Contract"> | Date | string | null
    endDate?: DateTimeNullableFilter<"Contract"> | Date | string | null
    employeeId?: StringFilter<"Contract"> | string
    createdAt?: DateTimeFilter<"Contract"> | Date | string
    updatedAt?: DateTimeFilter<"Contract"> | Date | string
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
    availability?: AvailabilityIntervalListRelationFilter
    amendments?: AmendmentListRelationFilter
  }, "id">

  export type ContractOrderByWithAggregationInput = {
    id?: SortOrder
    contractType?: SortOrderInput | SortOrder
    role?: SortOrderInput | SortOrder
    hoursPerWeek?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    resignationDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    employeeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ContractCountOrderByAggregateInput
    _avg?: ContractAvgOrderByAggregateInput
    _max?: ContractMaxOrderByAggregateInput
    _min?: ContractMinOrderByAggregateInput
    _sum?: ContractSumOrderByAggregateInput
  }

  export type ContractScalarWhereWithAggregatesInput = {
    AND?: ContractScalarWhereWithAggregatesInput | ContractScalarWhereWithAggregatesInput[]
    OR?: ContractScalarWhereWithAggregatesInput[]
    NOT?: ContractScalarWhereWithAggregatesInput | ContractScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Contract"> | string
    contractType?: StringNullableWithAggregatesFilter<"Contract"> | string | null
    role?: StringNullableWithAggregatesFilter<"Contract"> | string | null
    hoursPerWeek?: IntNullableWithAggregatesFilter<"Contract"> | number | null
    status?: EnumContractStatusNullableWithAggregatesFilter<"Contract"> | $Enums.ContractStatus | null
    resignationDate?: DateTimeNullableWithAggregatesFilter<"Contract"> | Date | string | null
    endDate?: DateTimeNullableWithAggregatesFilter<"Contract"> | Date | string | null
    employeeId?: StringWithAggregatesFilter<"Contract"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Contract"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Contract"> | Date | string
  }

  export type AvailabilityIntervalWhereInput = {
    AND?: AvailabilityIntervalWhereInput | AvailabilityIntervalWhereInput[]
    OR?: AvailabilityIntervalWhereInput[]
    NOT?: AvailabilityIntervalWhereInput | AvailabilityIntervalWhereInput[]
    id?: StringFilter<"AvailabilityInterval"> | string
    day?: EnumDayOfWeekFilter<"AvailabilityInterval"> | $Enums.DayOfWeek
    allDay?: BoolFilter<"AvailabilityInterval"> | boolean
    startTime?: StringNullableFilter<"AvailabilityInterval"> | string | null
    endTime?: StringNullableFilter<"AvailabilityInterval"> | string | null
    contractId?: StringFilter<"AvailabilityInterval"> | string
    contract?: XOR<ContractScalarRelationFilter, ContractWhereInput>
  }

  export type AvailabilityIntervalOrderByWithRelationInput = {
    id?: SortOrder
    day?: SortOrder
    allDay?: SortOrder
    startTime?: SortOrderInput | SortOrder
    endTime?: SortOrderInput | SortOrder
    contractId?: SortOrder
    contract?: ContractOrderByWithRelationInput
  }

  export type AvailabilityIntervalWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AvailabilityIntervalWhereInput | AvailabilityIntervalWhereInput[]
    OR?: AvailabilityIntervalWhereInput[]
    NOT?: AvailabilityIntervalWhereInput | AvailabilityIntervalWhereInput[]
    day?: EnumDayOfWeekFilter<"AvailabilityInterval"> | $Enums.DayOfWeek
    allDay?: BoolFilter<"AvailabilityInterval"> | boolean
    startTime?: StringNullableFilter<"AvailabilityInterval"> | string | null
    endTime?: StringNullableFilter<"AvailabilityInterval"> | string | null
    contractId?: StringFilter<"AvailabilityInterval"> | string
    contract?: XOR<ContractScalarRelationFilter, ContractWhereInput>
  }, "id">

  export type AvailabilityIntervalOrderByWithAggregationInput = {
    id?: SortOrder
    day?: SortOrder
    allDay?: SortOrder
    startTime?: SortOrderInput | SortOrder
    endTime?: SortOrderInput | SortOrder
    contractId?: SortOrder
    _count?: AvailabilityIntervalCountOrderByAggregateInput
    _max?: AvailabilityIntervalMaxOrderByAggregateInput
    _min?: AvailabilityIntervalMinOrderByAggregateInput
  }

  export type AvailabilityIntervalScalarWhereWithAggregatesInput = {
    AND?: AvailabilityIntervalScalarWhereWithAggregatesInput | AvailabilityIntervalScalarWhereWithAggregatesInput[]
    OR?: AvailabilityIntervalScalarWhereWithAggregatesInput[]
    NOT?: AvailabilityIntervalScalarWhereWithAggregatesInput | AvailabilityIntervalScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AvailabilityInterval"> | string
    day?: EnumDayOfWeekWithAggregatesFilter<"AvailabilityInterval"> | $Enums.DayOfWeek
    allDay?: BoolWithAggregatesFilter<"AvailabilityInterval"> | boolean
    startTime?: StringNullableWithAggregatesFilter<"AvailabilityInterval"> | string | null
    endTime?: StringNullableWithAggregatesFilter<"AvailabilityInterval"> | string | null
    contractId?: StringWithAggregatesFilter<"AvailabilityInterval"> | string
  }

  export type TimeRecordWhereInput = {
    AND?: TimeRecordWhereInput | TimeRecordWhereInput[]
    OR?: TimeRecordWhereInput[]
    NOT?: TimeRecordWhereInput | TimeRecordWhereInput[]
    id?: StringFilter<"TimeRecord"> | string
    date?: DateTimeFilter<"TimeRecord"> | Date | string
    checkIn?: DateTimeFilter<"TimeRecord"> | Date | string
    checkOut?: DateTimeNullableFilter<"TimeRecord"> | Date | string | null
    employeeId?: StringFilter<"TimeRecord"> | string
    createdAt?: DateTimeFilter<"TimeRecord"> | Date | string
    updatedAt?: DateTimeFilter<"TimeRecord"> | Date | string
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
  }

  export type TimeRecordOrderByWithRelationInput = {
    id?: SortOrder
    date?: SortOrder
    checkIn?: SortOrder
    checkOut?: SortOrderInput | SortOrder
    employeeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    employee?: EmployeeOrderByWithRelationInput
  }

  export type TimeRecordWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TimeRecordWhereInput | TimeRecordWhereInput[]
    OR?: TimeRecordWhereInput[]
    NOT?: TimeRecordWhereInput | TimeRecordWhereInput[]
    date?: DateTimeFilter<"TimeRecord"> | Date | string
    checkIn?: DateTimeFilter<"TimeRecord"> | Date | string
    checkOut?: DateTimeNullableFilter<"TimeRecord"> | Date | string | null
    employeeId?: StringFilter<"TimeRecord"> | string
    createdAt?: DateTimeFilter<"TimeRecord"> | Date | string
    updatedAt?: DateTimeFilter<"TimeRecord"> | Date | string
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
  }, "id">

  export type TimeRecordOrderByWithAggregationInput = {
    id?: SortOrder
    date?: SortOrder
    checkIn?: SortOrder
    checkOut?: SortOrderInput | SortOrder
    employeeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TimeRecordCountOrderByAggregateInput
    _max?: TimeRecordMaxOrderByAggregateInput
    _min?: TimeRecordMinOrderByAggregateInput
  }

  export type TimeRecordScalarWhereWithAggregatesInput = {
    AND?: TimeRecordScalarWhereWithAggregatesInput | TimeRecordScalarWhereWithAggregatesInput[]
    OR?: TimeRecordScalarWhereWithAggregatesInput[]
    NOT?: TimeRecordScalarWhereWithAggregatesInput | TimeRecordScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TimeRecord"> | string
    date?: DateTimeWithAggregatesFilter<"TimeRecord"> | Date | string
    checkIn?: DateTimeWithAggregatesFilter<"TimeRecord"> | Date | string
    checkOut?: DateTimeNullableWithAggregatesFilter<"TimeRecord"> | Date | string | null
    employeeId?: StringWithAggregatesFilter<"TimeRecord"> | string
    createdAt?: DateTimeWithAggregatesFilter<"TimeRecord"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TimeRecord"> | Date | string
  }

  export type ShiftWhereInput = {
    AND?: ShiftWhereInput | ShiftWhereInput[]
    OR?: ShiftWhereInput[]
    NOT?: ShiftWhereInput | ShiftWhereInput[]
    id?: StringFilter<"Shift"> | string
    date?: DateTimeFilter<"Shift"> | Date | string
    startHour?: FloatFilter<"Shift"> | number
    endHour?: FloatFilter<"Shift"> | number
    shiftType?: StringNullableFilter<"Shift"> | string | null
    employeeId?: StringFilter<"Shift"> | string
    createdAt?: DateTimeFilter<"Shift"> | Date | string
    updatedAt?: DateTimeFilter<"Shift"> | Date | string
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
  }

  export type ShiftOrderByWithRelationInput = {
    id?: SortOrder
    date?: SortOrder
    startHour?: SortOrder
    endHour?: SortOrder
    shiftType?: SortOrderInput | SortOrder
    employeeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    employee?: EmployeeOrderByWithRelationInput
  }

  export type ShiftWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ShiftWhereInput | ShiftWhereInput[]
    OR?: ShiftWhereInput[]
    NOT?: ShiftWhereInput | ShiftWhereInput[]
    date?: DateTimeFilter<"Shift"> | Date | string
    startHour?: FloatFilter<"Shift"> | number
    endHour?: FloatFilter<"Shift"> | number
    shiftType?: StringNullableFilter<"Shift"> | string | null
    employeeId?: StringFilter<"Shift"> | string
    createdAt?: DateTimeFilter<"Shift"> | Date | string
    updatedAt?: DateTimeFilter<"Shift"> | Date | string
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
  }, "id">

  export type ShiftOrderByWithAggregationInput = {
    id?: SortOrder
    date?: SortOrder
    startHour?: SortOrder
    endHour?: SortOrder
    shiftType?: SortOrderInput | SortOrder
    employeeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ShiftCountOrderByAggregateInput
    _avg?: ShiftAvgOrderByAggregateInput
    _max?: ShiftMaxOrderByAggregateInput
    _min?: ShiftMinOrderByAggregateInput
    _sum?: ShiftSumOrderByAggregateInput
  }

  export type ShiftScalarWhereWithAggregatesInput = {
    AND?: ShiftScalarWhereWithAggregatesInput | ShiftScalarWhereWithAggregatesInput[]
    OR?: ShiftScalarWhereWithAggregatesInput[]
    NOT?: ShiftScalarWhereWithAggregatesInput | ShiftScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Shift"> | string
    date?: DateTimeWithAggregatesFilter<"Shift"> | Date | string
    startHour?: FloatWithAggregatesFilter<"Shift"> | number
    endHour?: FloatWithAggregatesFilter<"Shift"> | number
    shiftType?: StringNullableWithAggregatesFilter<"Shift"> | string | null
    employeeId?: StringWithAggregatesFilter<"Shift"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Shift"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Shift"> | Date | string
  }

  export type DayLockWhereInput = {
    AND?: DayLockWhereInput | DayLockWhereInput[]
    OR?: DayLockWhereInput[]
    NOT?: DayLockWhereInput | DayLockWhereInput[]
    id?: StringFilter<"DayLock"> | string
    date?: DateTimeFilter<"DayLock"> | Date | string
    locked?: BoolFilter<"DayLock"> | boolean
    createdAt?: DateTimeFilter<"DayLock"> | Date | string
    updatedAt?: DateTimeFilter<"DayLock"> | Date | string
  }

  export type DayLockOrderByWithRelationInput = {
    id?: SortOrder
    date?: SortOrder
    locked?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DayLockWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    date?: Date | string
    AND?: DayLockWhereInput | DayLockWhereInput[]
    OR?: DayLockWhereInput[]
    NOT?: DayLockWhereInput | DayLockWhereInput[]
    locked?: BoolFilter<"DayLock"> | boolean
    createdAt?: DateTimeFilter<"DayLock"> | Date | string
    updatedAt?: DateTimeFilter<"DayLock"> | Date | string
  }, "id" | "date">

  export type DayLockOrderByWithAggregationInput = {
    id?: SortOrder
    date?: SortOrder
    locked?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DayLockCountOrderByAggregateInput
    _max?: DayLockMaxOrderByAggregateInput
    _min?: DayLockMinOrderByAggregateInput
  }

  export type DayLockScalarWhereWithAggregatesInput = {
    AND?: DayLockScalarWhereWithAggregatesInput | DayLockScalarWhereWithAggregatesInput[]
    OR?: DayLockScalarWhereWithAggregatesInput[]
    NOT?: DayLockScalarWhereWithAggregatesInput | DayLockScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DayLock"> | string
    date?: DateTimeWithAggregatesFilter<"DayLock"> | Date | string
    locked?: BoolWithAggregatesFilter<"DayLock"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"DayLock"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DayLock"> | Date | string
  }

  export type PayPeriodWhereInput = {
    AND?: PayPeriodWhereInput | PayPeriodWhereInput[]
    OR?: PayPeriodWhereInput[]
    NOT?: PayPeriodWhereInput | PayPeriodWhereInput[]
    id?: StringFilter<"PayPeriod"> | string
    startDate?: DateTimeFilter<"PayPeriod"> | Date | string
    endDate?: DateTimeFilter<"PayPeriod"> | Date | string
    createdAt?: DateTimeFilter<"PayPeriod"> | Date | string
    updatedAt?: DateTimeFilter<"PayPeriod"> | Date | string
    salaryMonth?: StringFilter<"PayPeriod"> | string
  }

  export type PayPeriodOrderByWithRelationInput = {
    id?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    salaryMonth?: SortOrder
  }

  export type PayPeriodWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PayPeriodWhereInput | PayPeriodWhereInput[]
    OR?: PayPeriodWhereInput[]
    NOT?: PayPeriodWhereInput | PayPeriodWhereInput[]
    startDate?: DateTimeFilter<"PayPeriod"> | Date | string
    endDate?: DateTimeFilter<"PayPeriod"> | Date | string
    createdAt?: DateTimeFilter<"PayPeriod"> | Date | string
    updatedAt?: DateTimeFilter<"PayPeriod"> | Date | string
    salaryMonth?: StringFilter<"PayPeriod"> | string
  }, "id">

  export type PayPeriodOrderByWithAggregationInput = {
    id?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    salaryMonth?: SortOrder
    _count?: PayPeriodCountOrderByAggregateInput
    _max?: PayPeriodMaxOrderByAggregateInput
    _min?: PayPeriodMinOrderByAggregateInput
  }

  export type PayPeriodScalarWhereWithAggregatesInput = {
    AND?: PayPeriodScalarWhereWithAggregatesInput | PayPeriodScalarWhereWithAggregatesInput[]
    OR?: PayPeriodScalarWhereWithAggregatesInput[]
    NOT?: PayPeriodScalarWhereWithAggregatesInput | PayPeriodScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PayPeriod"> | string
    startDate?: DateTimeWithAggregatesFilter<"PayPeriod"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"PayPeriod"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"PayPeriod"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PayPeriod"> | Date | string
    salaryMonth?: StringWithAggregatesFilter<"PayPeriod"> | string
  }

  export type AmendmentWhereInput = {
    AND?: AmendmentWhereInput | AmendmentWhereInput[]
    OR?: AmendmentWhereInput[]
    NOT?: AmendmentWhereInput | AmendmentWhereInput[]
    id?: StringFilter<"Amendment"> | string
    contractId?: StringFilter<"Amendment"> | string
    startDate?: DateTimeFilter<"Amendment"> | Date | string
    endDate?: DateTimeNullableFilter<"Amendment"> | Date | string | null
    newHoursPerWeek?: IntNullableFilter<"Amendment"> | number | null
    isTemporary?: BoolFilter<"Amendment"> | boolean
    createdAt?: DateTimeFilter<"Amendment"> | Date | string
    updatedAt?: DateTimeFilter<"Amendment"> | Date | string
    contract?: XOR<ContractScalarRelationFilter, ContractWhereInput>
  }

  export type AmendmentOrderByWithRelationInput = {
    id?: SortOrder
    contractId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    newHoursPerWeek?: SortOrderInput | SortOrder
    isTemporary?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    contract?: ContractOrderByWithRelationInput
  }

  export type AmendmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AmendmentWhereInput | AmendmentWhereInput[]
    OR?: AmendmentWhereInput[]
    NOT?: AmendmentWhereInput | AmendmentWhereInput[]
    contractId?: StringFilter<"Amendment"> | string
    startDate?: DateTimeFilter<"Amendment"> | Date | string
    endDate?: DateTimeNullableFilter<"Amendment"> | Date | string | null
    newHoursPerWeek?: IntNullableFilter<"Amendment"> | number | null
    isTemporary?: BoolFilter<"Amendment"> | boolean
    createdAt?: DateTimeFilter<"Amendment"> | Date | string
    updatedAt?: DateTimeFilter<"Amendment"> | Date | string
    contract?: XOR<ContractScalarRelationFilter, ContractWhereInput>
  }, "id">

  export type AmendmentOrderByWithAggregationInput = {
    id?: SortOrder
    contractId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    newHoursPerWeek?: SortOrderInput | SortOrder
    isTemporary?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AmendmentCountOrderByAggregateInput
    _avg?: AmendmentAvgOrderByAggregateInput
    _max?: AmendmentMaxOrderByAggregateInput
    _min?: AmendmentMinOrderByAggregateInput
    _sum?: AmendmentSumOrderByAggregateInput
  }

  export type AmendmentScalarWhereWithAggregatesInput = {
    AND?: AmendmentScalarWhereWithAggregatesInput | AmendmentScalarWhereWithAggregatesInput[]
    OR?: AmendmentScalarWhereWithAggregatesInput[]
    NOT?: AmendmentScalarWhereWithAggregatesInput | AmendmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Amendment"> | string
    contractId?: StringWithAggregatesFilter<"Amendment"> | string
    startDate?: DateTimeWithAggregatesFilter<"Amendment"> | Date | string
    endDate?: DateTimeNullableWithAggregatesFilter<"Amendment"> | Date | string | null
    newHoursPerWeek?: IntNullableWithAggregatesFilter<"Amendment"> | number | null
    isTemporary?: BoolWithAggregatesFilter<"Amendment"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Amendment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Amendment"> | Date | string
  }

  export type EmployeeCreateInput = {
    id?: string
    lastName?: string
    firstName?: string
    matricule?: number | null
    dateOfBirth?: Date | string | null
    sex?: $Enums.Sex | null
    nationality?: string | null
    address?: string | null
    address2?: string | null
    postalCode?: string | null
    city?: string | null
    iban?: string | null
    bic?: string | null
    socialSecurityNumber?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    transportMeans?: string | null
    photoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contracts?: ContractCreateNestedManyWithoutEmployeeInput
    timeRecords?: TimeRecordCreateNestedManyWithoutEmployeeInput
    shifts?: ShiftCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateInput = {
    id?: string
    lastName?: string
    firstName?: string
    matricule?: number | null
    dateOfBirth?: Date | string | null
    sex?: $Enums.Sex | null
    nationality?: string | null
    address?: string | null
    address2?: string | null
    postalCode?: string | null
    city?: string | null
    iban?: string | null
    bic?: string | null
    socialSecurityNumber?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    transportMeans?: string | null
    photoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contracts?: ContractUncheckedCreateNestedManyWithoutEmployeeInput
    timeRecords?: TimeRecordUncheckedCreateNestedManyWithoutEmployeeInput
    shifts?: ShiftUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    matricule?: NullableIntFieldUpdateOperationsInput | number | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: NullableEnumSexFieldUpdateOperationsInput | $Enums.Sex | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    address2?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    iban?: NullableStringFieldUpdateOperationsInput | string | null
    bic?: NullableStringFieldUpdateOperationsInput | string | null
    socialSecurityNumber?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    transportMeans?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contracts?: ContractUpdateManyWithoutEmployeeNestedInput
    timeRecords?: TimeRecordUpdateManyWithoutEmployeeNestedInput
    shifts?: ShiftUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    matricule?: NullableIntFieldUpdateOperationsInput | number | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: NullableEnumSexFieldUpdateOperationsInput | $Enums.Sex | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    address2?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    iban?: NullableStringFieldUpdateOperationsInput | string | null
    bic?: NullableStringFieldUpdateOperationsInput | string | null
    socialSecurityNumber?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    transportMeans?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contracts?: ContractUncheckedUpdateManyWithoutEmployeeNestedInput
    timeRecords?: TimeRecordUncheckedUpdateManyWithoutEmployeeNestedInput
    shifts?: ShiftUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeCreateManyInput = {
    id?: string
    lastName?: string
    firstName?: string
    matricule?: number | null
    dateOfBirth?: Date | string | null
    sex?: $Enums.Sex | null
    nationality?: string | null
    address?: string | null
    address2?: string | null
    postalCode?: string | null
    city?: string | null
    iban?: string | null
    bic?: string | null
    socialSecurityNumber?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    transportMeans?: string | null
    photoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployeeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    matricule?: NullableIntFieldUpdateOperationsInput | number | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: NullableEnumSexFieldUpdateOperationsInput | $Enums.Sex | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    address2?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    iban?: NullableStringFieldUpdateOperationsInput | string | null
    bic?: NullableStringFieldUpdateOperationsInput | string | null
    socialSecurityNumber?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    transportMeans?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    matricule?: NullableIntFieldUpdateOperationsInput | number | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: NullableEnumSexFieldUpdateOperationsInput | $Enums.Sex | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    address2?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    iban?: NullableStringFieldUpdateOperationsInput | string | null
    bic?: NullableStringFieldUpdateOperationsInput | string | null
    socialSecurityNumber?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    transportMeans?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContractCreateInput = {
    id?: string
    contractType?: string | null
    role?: string | null
    hoursPerWeek?: number | null
    status?: $Enums.ContractStatus | null
    resignationDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employee: EmployeeCreateNestedOneWithoutContractsInput
    availability?: AvailabilityIntervalCreateNestedManyWithoutContractInput
    amendments?: AmendmentCreateNestedManyWithoutContractInput
  }

  export type ContractUncheckedCreateInput = {
    id?: string
    contractType?: string | null
    role?: string | null
    hoursPerWeek?: number | null
    status?: $Enums.ContractStatus | null
    resignationDate?: Date | string | null
    endDate?: Date | string | null
    employeeId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    availability?: AvailabilityIntervalUncheckedCreateNestedManyWithoutContractInput
    amendments?: AmendmentUncheckedCreateNestedManyWithoutContractInput
  }

  export type ContractUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    contractType?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    hoursPerWeek?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumContractStatusFieldUpdateOperationsInput | $Enums.ContractStatus | null
    resignationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneRequiredWithoutContractsNestedInput
    availability?: AvailabilityIntervalUpdateManyWithoutContractNestedInput
    amendments?: AmendmentUpdateManyWithoutContractNestedInput
  }

  export type ContractUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    contractType?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    hoursPerWeek?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumContractStatusFieldUpdateOperationsInput | $Enums.ContractStatus | null
    resignationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employeeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    availability?: AvailabilityIntervalUncheckedUpdateManyWithoutContractNestedInput
    amendments?: AmendmentUncheckedUpdateManyWithoutContractNestedInput
  }

  export type ContractCreateManyInput = {
    id?: string
    contractType?: string | null
    role?: string | null
    hoursPerWeek?: number | null
    status?: $Enums.ContractStatus | null
    resignationDate?: Date | string | null
    endDate?: Date | string | null
    employeeId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContractUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    contractType?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    hoursPerWeek?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumContractStatusFieldUpdateOperationsInput | $Enums.ContractStatus | null
    resignationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContractUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    contractType?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    hoursPerWeek?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumContractStatusFieldUpdateOperationsInput | $Enums.ContractStatus | null
    resignationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employeeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AvailabilityIntervalCreateInput = {
    id?: string
    day: $Enums.DayOfWeek
    allDay: boolean
    startTime?: string | null
    endTime?: string | null
    contract: ContractCreateNestedOneWithoutAvailabilityInput
  }

  export type AvailabilityIntervalUncheckedCreateInput = {
    id?: string
    day: $Enums.DayOfWeek
    allDay: boolean
    startTime?: string | null
    endTime?: string | null
    contractId: string
  }

  export type AvailabilityIntervalUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    day?: EnumDayOfWeekFieldUpdateOperationsInput | $Enums.DayOfWeek
    allDay?: BoolFieldUpdateOperationsInput | boolean
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    contract?: ContractUpdateOneRequiredWithoutAvailabilityNestedInput
  }

  export type AvailabilityIntervalUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    day?: EnumDayOfWeekFieldUpdateOperationsInput | $Enums.DayOfWeek
    allDay?: BoolFieldUpdateOperationsInput | boolean
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    contractId?: StringFieldUpdateOperationsInput | string
  }

  export type AvailabilityIntervalCreateManyInput = {
    id?: string
    day: $Enums.DayOfWeek
    allDay: boolean
    startTime?: string | null
    endTime?: string | null
    contractId: string
  }

  export type AvailabilityIntervalUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    day?: EnumDayOfWeekFieldUpdateOperationsInput | $Enums.DayOfWeek
    allDay?: BoolFieldUpdateOperationsInput | boolean
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AvailabilityIntervalUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    day?: EnumDayOfWeekFieldUpdateOperationsInput | $Enums.DayOfWeek
    allDay?: BoolFieldUpdateOperationsInput | boolean
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    contractId?: StringFieldUpdateOperationsInput | string
  }

  export type TimeRecordCreateInput = {
    id?: string
    date: Date | string
    checkIn: Date | string
    checkOut?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employee: EmployeeCreateNestedOneWithoutTimeRecordsInput
  }

  export type TimeRecordUncheckedCreateInput = {
    id?: string
    date: Date | string
    checkIn: Date | string
    checkOut?: Date | string | null
    employeeId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TimeRecordUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    checkIn?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneRequiredWithoutTimeRecordsNestedInput
  }

  export type TimeRecordUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    checkIn?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employeeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TimeRecordCreateManyInput = {
    id?: string
    date: Date | string
    checkIn: Date | string
    checkOut?: Date | string | null
    employeeId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TimeRecordUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    checkIn?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TimeRecordUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    checkIn?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employeeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShiftCreateInput = {
    id?: string
    date: Date | string
    startHour: number
    endHour: number
    shiftType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employee: EmployeeCreateNestedOneWithoutShiftsInput
  }

  export type ShiftUncheckedCreateInput = {
    id?: string
    date: Date | string
    startHour: number
    endHour: number
    shiftType?: string | null
    employeeId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShiftUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startHour?: FloatFieldUpdateOperationsInput | number
    endHour?: FloatFieldUpdateOperationsInput | number
    shiftType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneRequiredWithoutShiftsNestedInput
  }

  export type ShiftUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startHour?: FloatFieldUpdateOperationsInput | number
    endHour?: FloatFieldUpdateOperationsInput | number
    shiftType?: NullableStringFieldUpdateOperationsInput | string | null
    employeeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShiftCreateManyInput = {
    id?: string
    date: Date | string
    startHour: number
    endHour: number
    shiftType?: string | null
    employeeId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShiftUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startHour?: FloatFieldUpdateOperationsInput | number
    endHour?: FloatFieldUpdateOperationsInput | number
    shiftType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShiftUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startHour?: FloatFieldUpdateOperationsInput | number
    endHour?: FloatFieldUpdateOperationsInput | number
    shiftType?: NullableStringFieldUpdateOperationsInput | string | null
    employeeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DayLockCreateInput = {
    id?: string
    date: Date | string
    locked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DayLockUncheckedCreateInput = {
    id?: string
    date: Date | string
    locked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DayLockUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    locked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DayLockUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    locked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DayLockCreateManyInput = {
    id?: string
    date: Date | string
    locked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DayLockUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    locked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DayLockUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    locked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayPeriodCreateInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    salaryMonth?: string
  }

  export type PayPeriodUncheckedCreateInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    salaryMonth?: string
  }

  export type PayPeriodUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    salaryMonth?: StringFieldUpdateOperationsInput | string
  }

  export type PayPeriodUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    salaryMonth?: StringFieldUpdateOperationsInput | string
  }

  export type PayPeriodCreateManyInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    salaryMonth?: string
  }

  export type PayPeriodUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    salaryMonth?: StringFieldUpdateOperationsInput | string
  }

  export type PayPeriodUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    salaryMonth?: StringFieldUpdateOperationsInput | string
  }

  export type AmendmentCreateInput = {
    id?: string
    startDate: Date | string
    endDate?: Date | string | null
    newHoursPerWeek?: number | null
    isTemporary: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    contract: ContractCreateNestedOneWithoutAmendmentsInput
  }

  export type AmendmentUncheckedCreateInput = {
    id?: string
    contractId: string
    startDate: Date | string
    endDate?: Date | string | null
    newHoursPerWeek?: number | null
    isTemporary: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AmendmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    newHoursPerWeek?: NullableIntFieldUpdateOperationsInput | number | null
    isTemporary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contract?: ContractUpdateOneRequiredWithoutAmendmentsNestedInput
  }

  export type AmendmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    contractId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    newHoursPerWeek?: NullableIntFieldUpdateOperationsInput | number | null
    isTemporary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AmendmentCreateManyInput = {
    id?: string
    contractId: string
    startDate: Date | string
    endDate?: Date | string | null
    newHoursPerWeek?: number | null
    isTemporary: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AmendmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    newHoursPerWeek?: NullableIntFieldUpdateOperationsInput | number | null
    isTemporary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AmendmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    contractId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    newHoursPerWeek?: NullableIntFieldUpdateOperationsInput | number | null
    isTemporary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type EnumSexNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Sex | EnumSexFieldRefInput<$PrismaModel> | null
    in?: $Enums.Sex[] | ListEnumSexFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Sex[] | ListEnumSexFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSexNullableFilter<$PrismaModel> | $Enums.Sex | null
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type ContractListRelationFilter = {
    every?: ContractWhereInput
    some?: ContractWhereInput
    none?: ContractWhereInput
  }

  export type TimeRecordListRelationFilter = {
    every?: TimeRecordWhereInput
    some?: TimeRecordWhereInput
    none?: TimeRecordWhereInput
  }

  export type ShiftListRelationFilter = {
    every?: ShiftWhereInput
    some?: ShiftWhereInput
    none?: ShiftWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ContractOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TimeRecordOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ShiftOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmployeeCountOrderByAggregateInput = {
    id?: SortOrder
    lastName?: SortOrder
    firstName?: SortOrder
    matricule?: SortOrder
    dateOfBirth?: SortOrder
    sex?: SortOrder
    nationality?: SortOrder
    address?: SortOrder
    address2?: SortOrder
    postalCode?: SortOrder
    city?: SortOrder
    iban?: SortOrder
    bic?: SortOrder
    socialSecurityNumber?: SortOrder
    emergencyContactName?: SortOrder
    emergencyContactPhone?: SortOrder
    transportMeans?: SortOrder
    photoUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmployeeAvgOrderByAggregateInput = {
    matricule?: SortOrder
  }

  export type EmployeeMaxOrderByAggregateInput = {
    id?: SortOrder
    lastName?: SortOrder
    firstName?: SortOrder
    matricule?: SortOrder
    dateOfBirth?: SortOrder
    sex?: SortOrder
    nationality?: SortOrder
    address?: SortOrder
    address2?: SortOrder
    postalCode?: SortOrder
    city?: SortOrder
    iban?: SortOrder
    bic?: SortOrder
    socialSecurityNumber?: SortOrder
    emergencyContactName?: SortOrder
    emergencyContactPhone?: SortOrder
    transportMeans?: SortOrder
    photoUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmployeeMinOrderByAggregateInput = {
    id?: SortOrder
    lastName?: SortOrder
    firstName?: SortOrder
    matricule?: SortOrder
    dateOfBirth?: SortOrder
    sex?: SortOrder
    nationality?: SortOrder
    address?: SortOrder
    address2?: SortOrder
    postalCode?: SortOrder
    city?: SortOrder
    iban?: SortOrder
    bic?: SortOrder
    socialSecurityNumber?: SortOrder
    emergencyContactName?: SortOrder
    emergencyContactPhone?: SortOrder
    transportMeans?: SortOrder
    photoUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmployeeSumOrderByAggregateInput = {
    matricule?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumSexNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Sex | EnumSexFieldRefInput<$PrismaModel> | null
    in?: $Enums.Sex[] | ListEnumSexFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Sex[] | ListEnumSexFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSexNullableWithAggregatesFilter<$PrismaModel> | $Enums.Sex | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumSexNullableFilter<$PrismaModel>
    _max?: NestedEnumSexNullableFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumContractStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ContractStatus | EnumContractStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.ContractStatus[] | ListEnumContractStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ContractStatus[] | ListEnumContractStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumContractStatusNullableFilter<$PrismaModel> | $Enums.ContractStatus | null
  }

  export type EmployeeScalarRelationFilter = {
    is?: EmployeeWhereInput
    isNot?: EmployeeWhereInput
  }

  export type AvailabilityIntervalListRelationFilter = {
    every?: AvailabilityIntervalWhereInput
    some?: AvailabilityIntervalWhereInput
    none?: AvailabilityIntervalWhereInput
  }

  export type AmendmentListRelationFilter = {
    every?: AmendmentWhereInput
    some?: AmendmentWhereInput
    none?: AmendmentWhereInput
  }

  export type AvailabilityIntervalOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AmendmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContractCountOrderByAggregateInput = {
    id?: SortOrder
    contractType?: SortOrder
    role?: SortOrder
    hoursPerWeek?: SortOrder
    status?: SortOrder
    resignationDate?: SortOrder
    endDate?: SortOrder
    employeeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContractAvgOrderByAggregateInput = {
    hoursPerWeek?: SortOrder
  }

  export type ContractMaxOrderByAggregateInput = {
    id?: SortOrder
    contractType?: SortOrder
    role?: SortOrder
    hoursPerWeek?: SortOrder
    status?: SortOrder
    resignationDate?: SortOrder
    endDate?: SortOrder
    employeeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContractMinOrderByAggregateInput = {
    id?: SortOrder
    contractType?: SortOrder
    role?: SortOrder
    hoursPerWeek?: SortOrder
    status?: SortOrder
    resignationDate?: SortOrder
    endDate?: SortOrder
    employeeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContractSumOrderByAggregateInput = {
    hoursPerWeek?: SortOrder
  }

  export type EnumContractStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContractStatus | EnumContractStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.ContractStatus[] | ListEnumContractStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ContractStatus[] | ListEnumContractStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumContractStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.ContractStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumContractStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumContractStatusNullableFilter<$PrismaModel>
  }

  export type EnumDayOfWeekFilter<$PrismaModel = never> = {
    equals?: $Enums.DayOfWeek | EnumDayOfWeekFieldRefInput<$PrismaModel>
    in?: $Enums.DayOfWeek[] | ListEnumDayOfWeekFieldRefInput<$PrismaModel>
    notIn?: $Enums.DayOfWeek[] | ListEnumDayOfWeekFieldRefInput<$PrismaModel>
    not?: NestedEnumDayOfWeekFilter<$PrismaModel> | $Enums.DayOfWeek
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type ContractScalarRelationFilter = {
    is?: ContractWhereInput
    isNot?: ContractWhereInput
  }

  export type AvailabilityIntervalCountOrderByAggregateInput = {
    id?: SortOrder
    day?: SortOrder
    allDay?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    contractId?: SortOrder
  }

  export type AvailabilityIntervalMaxOrderByAggregateInput = {
    id?: SortOrder
    day?: SortOrder
    allDay?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    contractId?: SortOrder
  }

  export type AvailabilityIntervalMinOrderByAggregateInput = {
    id?: SortOrder
    day?: SortOrder
    allDay?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    contractId?: SortOrder
  }

  export type EnumDayOfWeekWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DayOfWeek | EnumDayOfWeekFieldRefInput<$PrismaModel>
    in?: $Enums.DayOfWeek[] | ListEnumDayOfWeekFieldRefInput<$PrismaModel>
    notIn?: $Enums.DayOfWeek[] | ListEnumDayOfWeekFieldRefInput<$PrismaModel>
    not?: NestedEnumDayOfWeekWithAggregatesFilter<$PrismaModel> | $Enums.DayOfWeek
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDayOfWeekFilter<$PrismaModel>
    _max?: NestedEnumDayOfWeekFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type TimeRecordCountOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    checkIn?: SortOrder
    checkOut?: SortOrder
    employeeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TimeRecordMaxOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    checkIn?: SortOrder
    checkOut?: SortOrder
    employeeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TimeRecordMinOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    checkIn?: SortOrder
    checkOut?: SortOrder
    employeeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type ShiftCountOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    startHour?: SortOrder
    endHour?: SortOrder
    shiftType?: SortOrder
    employeeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShiftAvgOrderByAggregateInput = {
    startHour?: SortOrder
    endHour?: SortOrder
  }

  export type ShiftMaxOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    startHour?: SortOrder
    endHour?: SortOrder
    shiftType?: SortOrder
    employeeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShiftMinOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    startHour?: SortOrder
    endHour?: SortOrder
    shiftType?: SortOrder
    employeeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShiftSumOrderByAggregateInput = {
    startHour?: SortOrder
    endHour?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type DayLockCountOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    locked?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DayLockMaxOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    locked?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DayLockMinOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    locked?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PayPeriodCountOrderByAggregateInput = {
    id?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    salaryMonth?: SortOrder
  }

  export type PayPeriodMaxOrderByAggregateInput = {
    id?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    salaryMonth?: SortOrder
  }

  export type PayPeriodMinOrderByAggregateInput = {
    id?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    salaryMonth?: SortOrder
  }

  export type AmendmentCountOrderByAggregateInput = {
    id?: SortOrder
    contractId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    newHoursPerWeek?: SortOrder
    isTemporary?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AmendmentAvgOrderByAggregateInput = {
    newHoursPerWeek?: SortOrder
  }

  export type AmendmentMaxOrderByAggregateInput = {
    id?: SortOrder
    contractId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    newHoursPerWeek?: SortOrder
    isTemporary?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AmendmentMinOrderByAggregateInput = {
    id?: SortOrder
    contractId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    newHoursPerWeek?: SortOrder
    isTemporary?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AmendmentSumOrderByAggregateInput = {
    newHoursPerWeek?: SortOrder
  }

  export type ContractCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<ContractCreateWithoutEmployeeInput, ContractUncheckedCreateWithoutEmployeeInput> | ContractCreateWithoutEmployeeInput[] | ContractUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: ContractCreateOrConnectWithoutEmployeeInput | ContractCreateOrConnectWithoutEmployeeInput[]
    createMany?: ContractCreateManyEmployeeInputEnvelope
    connect?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
  }

  export type TimeRecordCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<TimeRecordCreateWithoutEmployeeInput, TimeRecordUncheckedCreateWithoutEmployeeInput> | TimeRecordCreateWithoutEmployeeInput[] | TimeRecordUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: TimeRecordCreateOrConnectWithoutEmployeeInput | TimeRecordCreateOrConnectWithoutEmployeeInput[]
    createMany?: TimeRecordCreateManyEmployeeInputEnvelope
    connect?: TimeRecordWhereUniqueInput | TimeRecordWhereUniqueInput[]
  }

  export type ShiftCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<ShiftCreateWithoutEmployeeInput, ShiftUncheckedCreateWithoutEmployeeInput> | ShiftCreateWithoutEmployeeInput[] | ShiftUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: ShiftCreateOrConnectWithoutEmployeeInput | ShiftCreateOrConnectWithoutEmployeeInput[]
    createMany?: ShiftCreateManyEmployeeInputEnvelope
    connect?: ShiftWhereUniqueInput | ShiftWhereUniqueInput[]
  }

  export type ContractUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<ContractCreateWithoutEmployeeInput, ContractUncheckedCreateWithoutEmployeeInput> | ContractCreateWithoutEmployeeInput[] | ContractUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: ContractCreateOrConnectWithoutEmployeeInput | ContractCreateOrConnectWithoutEmployeeInput[]
    createMany?: ContractCreateManyEmployeeInputEnvelope
    connect?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
  }

  export type TimeRecordUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<TimeRecordCreateWithoutEmployeeInput, TimeRecordUncheckedCreateWithoutEmployeeInput> | TimeRecordCreateWithoutEmployeeInput[] | TimeRecordUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: TimeRecordCreateOrConnectWithoutEmployeeInput | TimeRecordCreateOrConnectWithoutEmployeeInput[]
    createMany?: TimeRecordCreateManyEmployeeInputEnvelope
    connect?: TimeRecordWhereUniqueInput | TimeRecordWhereUniqueInput[]
  }

  export type ShiftUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<ShiftCreateWithoutEmployeeInput, ShiftUncheckedCreateWithoutEmployeeInput> | ShiftCreateWithoutEmployeeInput[] | ShiftUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: ShiftCreateOrConnectWithoutEmployeeInput | ShiftCreateOrConnectWithoutEmployeeInput[]
    createMany?: ShiftCreateManyEmployeeInputEnvelope
    connect?: ShiftWhereUniqueInput | ShiftWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableEnumSexFieldUpdateOperationsInput = {
    set?: $Enums.Sex | null
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type ContractUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<ContractCreateWithoutEmployeeInput, ContractUncheckedCreateWithoutEmployeeInput> | ContractCreateWithoutEmployeeInput[] | ContractUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: ContractCreateOrConnectWithoutEmployeeInput | ContractCreateOrConnectWithoutEmployeeInput[]
    upsert?: ContractUpsertWithWhereUniqueWithoutEmployeeInput | ContractUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: ContractCreateManyEmployeeInputEnvelope
    set?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    disconnect?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    delete?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    connect?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    update?: ContractUpdateWithWhereUniqueWithoutEmployeeInput | ContractUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: ContractUpdateManyWithWhereWithoutEmployeeInput | ContractUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: ContractScalarWhereInput | ContractScalarWhereInput[]
  }

  export type TimeRecordUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<TimeRecordCreateWithoutEmployeeInput, TimeRecordUncheckedCreateWithoutEmployeeInput> | TimeRecordCreateWithoutEmployeeInput[] | TimeRecordUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: TimeRecordCreateOrConnectWithoutEmployeeInput | TimeRecordCreateOrConnectWithoutEmployeeInput[]
    upsert?: TimeRecordUpsertWithWhereUniqueWithoutEmployeeInput | TimeRecordUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: TimeRecordCreateManyEmployeeInputEnvelope
    set?: TimeRecordWhereUniqueInput | TimeRecordWhereUniqueInput[]
    disconnect?: TimeRecordWhereUniqueInput | TimeRecordWhereUniqueInput[]
    delete?: TimeRecordWhereUniqueInput | TimeRecordWhereUniqueInput[]
    connect?: TimeRecordWhereUniqueInput | TimeRecordWhereUniqueInput[]
    update?: TimeRecordUpdateWithWhereUniqueWithoutEmployeeInput | TimeRecordUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: TimeRecordUpdateManyWithWhereWithoutEmployeeInput | TimeRecordUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: TimeRecordScalarWhereInput | TimeRecordScalarWhereInput[]
  }

  export type ShiftUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<ShiftCreateWithoutEmployeeInput, ShiftUncheckedCreateWithoutEmployeeInput> | ShiftCreateWithoutEmployeeInput[] | ShiftUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: ShiftCreateOrConnectWithoutEmployeeInput | ShiftCreateOrConnectWithoutEmployeeInput[]
    upsert?: ShiftUpsertWithWhereUniqueWithoutEmployeeInput | ShiftUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: ShiftCreateManyEmployeeInputEnvelope
    set?: ShiftWhereUniqueInput | ShiftWhereUniqueInput[]
    disconnect?: ShiftWhereUniqueInput | ShiftWhereUniqueInput[]
    delete?: ShiftWhereUniqueInput | ShiftWhereUniqueInput[]
    connect?: ShiftWhereUniqueInput | ShiftWhereUniqueInput[]
    update?: ShiftUpdateWithWhereUniqueWithoutEmployeeInput | ShiftUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: ShiftUpdateManyWithWhereWithoutEmployeeInput | ShiftUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: ShiftScalarWhereInput | ShiftScalarWhereInput[]
  }

  export type ContractUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<ContractCreateWithoutEmployeeInput, ContractUncheckedCreateWithoutEmployeeInput> | ContractCreateWithoutEmployeeInput[] | ContractUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: ContractCreateOrConnectWithoutEmployeeInput | ContractCreateOrConnectWithoutEmployeeInput[]
    upsert?: ContractUpsertWithWhereUniqueWithoutEmployeeInput | ContractUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: ContractCreateManyEmployeeInputEnvelope
    set?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    disconnect?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    delete?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    connect?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    update?: ContractUpdateWithWhereUniqueWithoutEmployeeInput | ContractUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: ContractUpdateManyWithWhereWithoutEmployeeInput | ContractUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: ContractScalarWhereInput | ContractScalarWhereInput[]
  }

  export type TimeRecordUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<TimeRecordCreateWithoutEmployeeInput, TimeRecordUncheckedCreateWithoutEmployeeInput> | TimeRecordCreateWithoutEmployeeInput[] | TimeRecordUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: TimeRecordCreateOrConnectWithoutEmployeeInput | TimeRecordCreateOrConnectWithoutEmployeeInput[]
    upsert?: TimeRecordUpsertWithWhereUniqueWithoutEmployeeInput | TimeRecordUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: TimeRecordCreateManyEmployeeInputEnvelope
    set?: TimeRecordWhereUniqueInput | TimeRecordWhereUniqueInput[]
    disconnect?: TimeRecordWhereUniqueInput | TimeRecordWhereUniqueInput[]
    delete?: TimeRecordWhereUniqueInput | TimeRecordWhereUniqueInput[]
    connect?: TimeRecordWhereUniqueInput | TimeRecordWhereUniqueInput[]
    update?: TimeRecordUpdateWithWhereUniqueWithoutEmployeeInput | TimeRecordUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: TimeRecordUpdateManyWithWhereWithoutEmployeeInput | TimeRecordUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: TimeRecordScalarWhereInput | TimeRecordScalarWhereInput[]
  }

  export type ShiftUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<ShiftCreateWithoutEmployeeInput, ShiftUncheckedCreateWithoutEmployeeInput> | ShiftCreateWithoutEmployeeInput[] | ShiftUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: ShiftCreateOrConnectWithoutEmployeeInput | ShiftCreateOrConnectWithoutEmployeeInput[]
    upsert?: ShiftUpsertWithWhereUniqueWithoutEmployeeInput | ShiftUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: ShiftCreateManyEmployeeInputEnvelope
    set?: ShiftWhereUniqueInput | ShiftWhereUniqueInput[]
    disconnect?: ShiftWhereUniqueInput | ShiftWhereUniqueInput[]
    delete?: ShiftWhereUniqueInput | ShiftWhereUniqueInput[]
    connect?: ShiftWhereUniqueInput | ShiftWhereUniqueInput[]
    update?: ShiftUpdateWithWhereUniqueWithoutEmployeeInput | ShiftUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: ShiftUpdateManyWithWhereWithoutEmployeeInput | ShiftUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: ShiftScalarWhereInput | ShiftScalarWhereInput[]
  }

  export type EmployeeCreateNestedOneWithoutContractsInput = {
    create?: XOR<EmployeeCreateWithoutContractsInput, EmployeeUncheckedCreateWithoutContractsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutContractsInput
    connect?: EmployeeWhereUniqueInput
  }

  export type AvailabilityIntervalCreateNestedManyWithoutContractInput = {
    create?: XOR<AvailabilityIntervalCreateWithoutContractInput, AvailabilityIntervalUncheckedCreateWithoutContractInput> | AvailabilityIntervalCreateWithoutContractInput[] | AvailabilityIntervalUncheckedCreateWithoutContractInput[]
    connectOrCreate?: AvailabilityIntervalCreateOrConnectWithoutContractInput | AvailabilityIntervalCreateOrConnectWithoutContractInput[]
    createMany?: AvailabilityIntervalCreateManyContractInputEnvelope
    connect?: AvailabilityIntervalWhereUniqueInput | AvailabilityIntervalWhereUniqueInput[]
  }

  export type AmendmentCreateNestedManyWithoutContractInput = {
    create?: XOR<AmendmentCreateWithoutContractInput, AmendmentUncheckedCreateWithoutContractInput> | AmendmentCreateWithoutContractInput[] | AmendmentUncheckedCreateWithoutContractInput[]
    connectOrCreate?: AmendmentCreateOrConnectWithoutContractInput | AmendmentCreateOrConnectWithoutContractInput[]
    createMany?: AmendmentCreateManyContractInputEnvelope
    connect?: AmendmentWhereUniqueInput | AmendmentWhereUniqueInput[]
  }

  export type AvailabilityIntervalUncheckedCreateNestedManyWithoutContractInput = {
    create?: XOR<AvailabilityIntervalCreateWithoutContractInput, AvailabilityIntervalUncheckedCreateWithoutContractInput> | AvailabilityIntervalCreateWithoutContractInput[] | AvailabilityIntervalUncheckedCreateWithoutContractInput[]
    connectOrCreate?: AvailabilityIntervalCreateOrConnectWithoutContractInput | AvailabilityIntervalCreateOrConnectWithoutContractInput[]
    createMany?: AvailabilityIntervalCreateManyContractInputEnvelope
    connect?: AvailabilityIntervalWhereUniqueInput | AvailabilityIntervalWhereUniqueInput[]
  }

  export type AmendmentUncheckedCreateNestedManyWithoutContractInput = {
    create?: XOR<AmendmentCreateWithoutContractInput, AmendmentUncheckedCreateWithoutContractInput> | AmendmentCreateWithoutContractInput[] | AmendmentUncheckedCreateWithoutContractInput[]
    connectOrCreate?: AmendmentCreateOrConnectWithoutContractInput | AmendmentCreateOrConnectWithoutContractInput[]
    createMany?: AmendmentCreateManyContractInputEnvelope
    connect?: AmendmentWhereUniqueInput | AmendmentWhereUniqueInput[]
  }

  export type NullableEnumContractStatusFieldUpdateOperationsInput = {
    set?: $Enums.ContractStatus | null
  }

  export type EmployeeUpdateOneRequiredWithoutContractsNestedInput = {
    create?: XOR<EmployeeCreateWithoutContractsInput, EmployeeUncheckedCreateWithoutContractsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutContractsInput
    upsert?: EmployeeUpsertWithoutContractsInput
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutContractsInput, EmployeeUpdateWithoutContractsInput>, EmployeeUncheckedUpdateWithoutContractsInput>
  }

  export type AvailabilityIntervalUpdateManyWithoutContractNestedInput = {
    create?: XOR<AvailabilityIntervalCreateWithoutContractInput, AvailabilityIntervalUncheckedCreateWithoutContractInput> | AvailabilityIntervalCreateWithoutContractInput[] | AvailabilityIntervalUncheckedCreateWithoutContractInput[]
    connectOrCreate?: AvailabilityIntervalCreateOrConnectWithoutContractInput | AvailabilityIntervalCreateOrConnectWithoutContractInput[]
    upsert?: AvailabilityIntervalUpsertWithWhereUniqueWithoutContractInput | AvailabilityIntervalUpsertWithWhereUniqueWithoutContractInput[]
    createMany?: AvailabilityIntervalCreateManyContractInputEnvelope
    set?: AvailabilityIntervalWhereUniqueInput | AvailabilityIntervalWhereUniqueInput[]
    disconnect?: AvailabilityIntervalWhereUniqueInput | AvailabilityIntervalWhereUniqueInput[]
    delete?: AvailabilityIntervalWhereUniqueInput | AvailabilityIntervalWhereUniqueInput[]
    connect?: AvailabilityIntervalWhereUniqueInput | AvailabilityIntervalWhereUniqueInput[]
    update?: AvailabilityIntervalUpdateWithWhereUniqueWithoutContractInput | AvailabilityIntervalUpdateWithWhereUniqueWithoutContractInput[]
    updateMany?: AvailabilityIntervalUpdateManyWithWhereWithoutContractInput | AvailabilityIntervalUpdateManyWithWhereWithoutContractInput[]
    deleteMany?: AvailabilityIntervalScalarWhereInput | AvailabilityIntervalScalarWhereInput[]
  }

  export type AmendmentUpdateManyWithoutContractNestedInput = {
    create?: XOR<AmendmentCreateWithoutContractInput, AmendmentUncheckedCreateWithoutContractInput> | AmendmentCreateWithoutContractInput[] | AmendmentUncheckedCreateWithoutContractInput[]
    connectOrCreate?: AmendmentCreateOrConnectWithoutContractInput | AmendmentCreateOrConnectWithoutContractInput[]
    upsert?: AmendmentUpsertWithWhereUniqueWithoutContractInput | AmendmentUpsertWithWhereUniqueWithoutContractInput[]
    createMany?: AmendmentCreateManyContractInputEnvelope
    set?: AmendmentWhereUniqueInput | AmendmentWhereUniqueInput[]
    disconnect?: AmendmentWhereUniqueInput | AmendmentWhereUniqueInput[]
    delete?: AmendmentWhereUniqueInput | AmendmentWhereUniqueInput[]
    connect?: AmendmentWhereUniqueInput | AmendmentWhereUniqueInput[]
    update?: AmendmentUpdateWithWhereUniqueWithoutContractInput | AmendmentUpdateWithWhereUniqueWithoutContractInput[]
    updateMany?: AmendmentUpdateManyWithWhereWithoutContractInput | AmendmentUpdateManyWithWhereWithoutContractInput[]
    deleteMany?: AmendmentScalarWhereInput | AmendmentScalarWhereInput[]
  }

  export type AvailabilityIntervalUncheckedUpdateManyWithoutContractNestedInput = {
    create?: XOR<AvailabilityIntervalCreateWithoutContractInput, AvailabilityIntervalUncheckedCreateWithoutContractInput> | AvailabilityIntervalCreateWithoutContractInput[] | AvailabilityIntervalUncheckedCreateWithoutContractInput[]
    connectOrCreate?: AvailabilityIntervalCreateOrConnectWithoutContractInput | AvailabilityIntervalCreateOrConnectWithoutContractInput[]
    upsert?: AvailabilityIntervalUpsertWithWhereUniqueWithoutContractInput | AvailabilityIntervalUpsertWithWhereUniqueWithoutContractInput[]
    createMany?: AvailabilityIntervalCreateManyContractInputEnvelope
    set?: AvailabilityIntervalWhereUniqueInput | AvailabilityIntervalWhereUniqueInput[]
    disconnect?: AvailabilityIntervalWhereUniqueInput | AvailabilityIntervalWhereUniqueInput[]
    delete?: AvailabilityIntervalWhereUniqueInput | AvailabilityIntervalWhereUniqueInput[]
    connect?: AvailabilityIntervalWhereUniqueInput | AvailabilityIntervalWhereUniqueInput[]
    update?: AvailabilityIntervalUpdateWithWhereUniqueWithoutContractInput | AvailabilityIntervalUpdateWithWhereUniqueWithoutContractInput[]
    updateMany?: AvailabilityIntervalUpdateManyWithWhereWithoutContractInput | AvailabilityIntervalUpdateManyWithWhereWithoutContractInput[]
    deleteMany?: AvailabilityIntervalScalarWhereInput | AvailabilityIntervalScalarWhereInput[]
  }

  export type AmendmentUncheckedUpdateManyWithoutContractNestedInput = {
    create?: XOR<AmendmentCreateWithoutContractInput, AmendmentUncheckedCreateWithoutContractInput> | AmendmentCreateWithoutContractInput[] | AmendmentUncheckedCreateWithoutContractInput[]
    connectOrCreate?: AmendmentCreateOrConnectWithoutContractInput | AmendmentCreateOrConnectWithoutContractInput[]
    upsert?: AmendmentUpsertWithWhereUniqueWithoutContractInput | AmendmentUpsertWithWhereUniqueWithoutContractInput[]
    createMany?: AmendmentCreateManyContractInputEnvelope
    set?: AmendmentWhereUniqueInput | AmendmentWhereUniqueInput[]
    disconnect?: AmendmentWhereUniqueInput | AmendmentWhereUniqueInput[]
    delete?: AmendmentWhereUniqueInput | AmendmentWhereUniqueInput[]
    connect?: AmendmentWhereUniqueInput | AmendmentWhereUniqueInput[]
    update?: AmendmentUpdateWithWhereUniqueWithoutContractInput | AmendmentUpdateWithWhereUniqueWithoutContractInput[]
    updateMany?: AmendmentUpdateManyWithWhereWithoutContractInput | AmendmentUpdateManyWithWhereWithoutContractInput[]
    deleteMany?: AmendmentScalarWhereInput | AmendmentScalarWhereInput[]
  }

  export type ContractCreateNestedOneWithoutAvailabilityInput = {
    create?: XOR<ContractCreateWithoutAvailabilityInput, ContractUncheckedCreateWithoutAvailabilityInput>
    connectOrCreate?: ContractCreateOrConnectWithoutAvailabilityInput
    connect?: ContractWhereUniqueInput
  }

  export type EnumDayOfWeekFieldUpdateOperationsInput = {
    set?: $Enums.DayOfWeek
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type ContractUpdateOneRequiredWithoutAvailabilityNestedInput = {
    create?: XOR<ContractCreateWithoutAvailabilityInput, ContractUncheckedCreateWithoutAvailabilityInput>
    connectOrCreate?: ContractCreateOrConnectWithoutAvailabilityInput
    upsert?: ContractUpsertWithoutAvailabilityInput
    connect?: ContractWhereUniqueInput
    update?: XOR<XOR<ContractUpdateToOneWithWhereWithoutAvailabilityInput, ContractUpdateWithoutAvailabilityInput>, ContractUncheckedUpdateWithoutAvailabilityInput>
  }

  export type EmployeeCreateNestedOneWithoutTimeRecordsInput = {
    create?: XOR<EmployeeCreateWithoutTimeRecordsInput, EmployeeUncheckedCreateWithoutTimeRecordsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutTimeRecordsInput
    connect?: EmployeeWhereUniqueInput
  }

  export type EmployeeUpdateOneRequiredWithoutTimeRecordsNestedInput = {
    create?: XOR<EmployeeCreateWithoutTimeRecordsInput, EmployeeUncheckedCreateWithoutTimeRecordsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutTimeRecordsInput
    upsert?: EmployeeUpsertWithoutTimeRecordsInput
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutTimeRecordsInput, EmployeeUpdateWithoutTimeRecordsInput>, EmployeeUncheckedUpdateWithoutTimeRecordsInput>
  }

  export type EmployeeCreateNestedOneWithoutShiftsInput = {
    create?: XOR<EmployeeCreateWithoutShiftsInput, EmployeeUncheckedCreateWithoutShiftsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutShiftsInput
    connect?: EmployeeWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EmployeeUpdateOneRequiredWithoutShiftsNestedInput = {
    create?: XOR<EmployeeCreateWithoutShiftsInput, EmployeeUncheckedCreateWithoutShiftsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutShiftsInput
    upsert?: EmployeeUpsertWithoutShiftsInput
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutShiftsInput, EmployeeUpdateWithoutShiftsInput>, EmployeeUncheckedUpdateWithoutShiftsInput>
  }

  export type ContractCreateNestedOneWithoutAmendmentsInput = {
    create?: XOR<ContractCreateWithoutAmendmentsInput, ContractUncheckedCreateWithoutAmendmentsInput>
    connectOrCreate?: ContractCreateOrConnectWithoutAmendmentsInput
    connect?: ContractWhereUniqueInput
  }

  export type ContractUpdateOneRequiredWithoutAmendmentsNestedInput = {
    create?: XOR<ContractCreateWithoutAmendmentsInput, ContractUncheckedCreateWithoutAmendmentsInput>
    connectOrCreate?: ContractCreateOrConnectWithoutAmendmentsInput
    upsert?: ContractUpsertWithoutAmendmentsInput
    connect?: ContractWhereUniqueInput
    update?: XOR<XOR<ContractUpdateToOneWithWhereWithoutAmendmentsInput, ContractUpdateWithoutAmendmentsInput>, ContractUncheckedUpdateWithoutAmendmentsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumSexNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Sex | EnumSexFieldRefInput<$PrismaModel> | null
    in?: $Enums.Sex[] | ListEnumSexFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Sex[] | ListEnumSexFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSexNullableFilter<$PrismaModel> | $Enums.Sex | null
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumSexNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Sex | EnumSexFieldRefInput<$PrismaModel> | null
    in?: $Enums.Sex[] | ListEnumSexFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Sex[] | ListEnumSexFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSexNullableWithAggregatesFilter<$PrismaModel> | $Enums.Sex | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumSexNullableFilter<$PrismaModel>
    _max?: NestedEnumSexNullableFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumContractStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ContractStatus | EnumContractStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.ContractStatus[] | ListEnumContractStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ContractStatus[] | ListEnumContractStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumContractStatusNullableFilter<$PrismaModel> | $Enums.ContractStatus | null
  }

  export type NestedEnumContractStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContractStatus | EnumContractStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.ContractStatus[] | ListEnumContractStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ContractStatus[] | ListEnumContractStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumContractStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.ContractStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumContractStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumContractStatusNullableFilter<$PrismaModel>
  }

  export type NestedEnumDayOfWeekFilter<$PrismaModel = never> = {
    equals?: $Enums.DayOfWeek | EnumDayOfWeekFieldRefInput<$PrismaModel>
    in?: $Enums.DayOfWeek[] | ListEnumDayOfWeekFieldRefInput<$PrismaModel>
    notIn?: $Enums.DayOfWeek[] | ListEnumDayOfWeekFieldRefInput<$PrismaModel>
    not?: NestedEnumDayOfWeekFilter<$PrismaModel> | $Enums.DayOfWeek
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumDayOfWeekWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DayOfWeek | EnumDayOfWeekFieldRefInput<$PrismaModel>
    in?: $Enums.DayOfWeek[] | ListEnumDayOfWeekFieldRefInput<$PrismaModel>
    notIn?: $Enums.DayOfWeek[] | ListEnumDayOfWeekFieldRefInput<$PrismaModel>
    not?: NestedEnumDayOfWeekWithAggregatesFilter<$PrismaModel> | $Enums.DayOfWeek
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDayOfWeekFilter<$PrismaModel>
    _max?: NestedEnumDayOfWeekFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type ContractCreateWithoutEmployeeInput = {
    id?: string
    contractType?: string | null
    role?: string | null
    hoursPerWeek?: number | null
    status?: $Enums.ContractStatus | null
    resignationDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    availability?: AvailabilityIntervalCreateNestedManyWithoutContractInput
    amendments?: AmendmentCreateNestedManyWithoutContractInput
  }

  export type ContractUncheckedCreateWithoutEmployeeInput = {
    id?: string
    contractType?: string | null
    role?: string | null
    hoursPerWeek?: number | null
    status?: $Enums.ContractStatus | null
    resignationDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    availability?: AvailabilityIntervalUncheckedCreateNestedManyWithoutContractInput
    amendments?: AmendmentUncheckedCreateNestedManyWithoutContractInput
  }

  export type ContractCreateOrConnectWithoutEmployeeInput = {
    where: ContractWhereUniqueInput
    create: XOR<ContractCreateWithoutEmployeeInput, ContractUncheckedCreateWithoutEmployeeInput>
  }

  export type ContractCreateManyEmployeeInputEnvelope = {
    data: ContractCreateManyEmployeeInput | ContractCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type TimeRecordCreateWithoutEmployeeInput = {
    id?: string
    date: Date | string
    checkIn: Date | string
    checkOut?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TimeRecordUncheckedCreateWithoutEmployeeInput = {
    id?: string
    date: Date | string
    checkIn: Date | string
    checkOut?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TimeRecordCreateOrConnectWithoutEmployeeInput = {
    where: TimeRecordWhereUniqueInput
    create: XOR<TimeRecordCreateWithoutEmployeeInput, TimeRecordUncheckedCreateWithoutEmployeeInput>
  }

  export type TimeRecordCreateManyEmployeeInputEnvelope = {
    data: TimeRecordCreateManyEmployeeInput | TimeRecordCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type ShiftCreateWithoutEmployeeInput = {
    id?: string
    date: Date | string
    startHour: number
    endHour: number
    shiftType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShiftUncheckedCreateWithoutEmployeeInput = {
    id?: string
    date: Date | string
    startHour: number
    endHour: number
    shiftType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShiftCreateOrConnectWithoutEmployeeInput = {
    where: ShiftWhereUniqueInput
    create: XOR<ShiftCreateWithoutEmployeeInput, ShiftUncheckedCreateWithoutEmployeeInput>
  }

  export type ShiftCreateManyEmployeeInputEnvelope = {
    data: ShiftCreateManyEmployeeInput | ShiftCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type ContractUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: ContractWhereUniqueInput
    update: XOR<ContractUpdateWithoutEmployeeInput, ContractUncheckedUpdateWithoutEmployeeInput>
    create: XOR<ContractCreateWithoutEmployeeInput, ContractUncheckedCreateWithoutEmployeeInput>
  }

  export type ContractUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: ContractWhereUniqueInput
    data: XOR<ContractUpdateWithoutEmployeeInput, ContractUncheckedUpdateWithoutEmployeeInput>
  }

  export type ContractUpdateManyWithWhereWithoutEmployeeInput = {
    where: ContractScalarWhereInput
    data: XOR<ContractUpdateManyMutationInput, ContractUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type ContractScalarWhereInput = {
    AND?: ContractScalarWhereInput | ContractScalarWhereInput[]
    OR?: ContractScalarWhereInput[]
    NOT?: ContractScalarWhereInput | ContractScalarWhereInput[]
    id?: StringFilter<"Contract"> | string
    contractType?: StringNullableFilter<"Contract"> | string | null
    role?: StringNullableFilter<"Contract"> | string | null
    hoursPerWeek?: IntNullableFilter<"Contract"> | number | null
    status?: EnumContractStatusNullableFilter<"Contract"> | $Enums.ContractStatus | null
    resignationDate?: DateTimeNullableFilter<"Contract"> | Date | string | null
    endDate?: DateTimeNullableFilter<"Contract"> | Date | string | null
    employeeId?: StringFilter<"Contract"> | string
    createdAt?: DateTimeFilter<"Contract"> | Date | string
    updatedAt?: DateTimeFilter<"Contract"> | Date | string
  }

  export type TimeRecordUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: TimeRecordWhereUniqueInput
    update: XOR<TimeRecordUpdateWithoutEmployeeInput, TimeRecordUncheckedUpdateWithoutEmployeeInput>
    create: XOR<TimeRecordCreateWithoutEmployeeInput, TimeRecordUncheckedCreateWithoutEmployeeInput>
  }

  export type TimeRecordUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: TimeRecordWhereUniqueInput
    data: XOR<TimeRecordUpdateWithoutEmployeeInput, TimeRecordUncheckedUpdateWithoutEmployeeInput>
  }

  export type TimeRecordUpdateManyWithWhereWithoutEmployeeInput = {
    where: TimeRecordScalarWhereInput
    data: XOR<TimeRecordUpdateManyMutationInput, TimeRecordUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type TimeRecordScalarWhereInput = {
    AND?: TimeRecordScalarWhereInput | TimeRecordScalarWhereInput[]
    OR?: TimeRecordScalarWhereInput[]
    NOT?: TimeRecordScalarWhereInput | TimeRecordScalarWhereInput[]
    id?: StringFilter<"TimeRecord"> | string
    date?: DateTimeFilter<"TimeRecord"> | Date | string
    checkIn?: DateTimeFilter<"TimeRecord"> | Date | string
    checkOut?: DateTimeNullableFilter<"TimeRecord"> | Date | string | null
    employeeId?: StringFilter<"TimeRecord"> | string
    createdAt?: DateTimeFilter<"TimeRecord"> | Date | string
    updatedAt?: DateTimeFilter<"TimeRecord"> | Date | string
  }

  export type ShiftUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: ShiftWhereUniqueInput
    update: XOR<ShiftUpdateWithoutEmployeeInput, ShiftUncheckedUpdateWithoutEmployeeInput>
    create: XOR<ShiftCreateWithoutEmployeeInput, ShiftUncheckedCreateWithoutEmployeeInput>
  }

  export type ShiftUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: ShiftWhereUniqueInput
    data: XOR<ShiftUpdateWithoutEmployeeInput, ShiftUncheckedUpdateWithoutEmployeeInput>
  }

  export type ShiftUpdateManyWithWhereWithoutEmployeeInput = {
    where: ShiftScalarWhereInput
    data: XOR<ShiftUpdateManyMutationInput, ShiftUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type ShiftScalarWhereInput = {
    AND?: ShiftScalarWhereInput | ShiftScalarWhereInput[]
    OR?: ShiftScalarWhereInput[]
    NOT?: ShiftScalarWhereInput | ShiftScalarWhereInput[]
    id?: StringFilter<"Shift"> | string
    date?: DateTimeFilter<"Shift"> | Date | string
    startHour?: FloatFilter<"Shift"> | number
    endHour?: FloatFilter<"Shift"> | number
    shiftType?: StringNullableFilter<"Shift"> | string | null
    employeeId?: StringFilter<"Shift"> | string
    createdAt?: DateTimeFilter<"Shift"> | Date | string
    updatedAt?: DateTimeFilter<"Shift"> | Date | string
  }

  export type EmployeeCreateWithoutContractsInput = {
    id?: string
    lastName?: string
    firstName?: string
    matricule?: number | null
    dateOfBirth?: Date | string | null
    sex?: $Enums.Sex | null
    nationality?: string | null
    address?: string | null
    address2?: string | null
    postalCode?: string | null
    city?: string | null
    iban?: string | null
    bic?: string | null
    socialSecurityNumber?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    transportMeans?: string | null
    photoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    timeRecords?: TimeRecordCreateNestedManyWithoutEmployeeInput
    shifts?: ShiftCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutContractsInput = {
    id?: string
    lastName?: string
    firstName?: string
    matricule?: number | null
    dateOfBirth?: Date | string | null
    sex?: $Enums.Sex | null
    nationality?: string | null
    address?: string | null
    address2?: string | null
    postalCode?: string | null
    city?: string | null
    iban?: string | null
    bic?: string | null
    socialSecurityNumber?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    transportMeans?: string | null
    photoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    timeRecords?: TimeRecordUncheckedCreateNestedManyWithoutEmployeeInput
    shifts?: ShiftUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutContractsInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutContractsInput, EmployeeUncheckedCreateWithoutContractsInput>
  }

  export type AvailabilityIntervalCreateWithoutContractInput = {
    id?: string
    day: $Enums.DayOfWeek
    allDay: boolean
    startTime?: string | null
    endTime?: string | null
  }

  export type AvailabilityIntervalUncheckedCreateWithoutContractInput = {
    id?: string
    day: $Enums.DayOfWeek
    allDay: boolean
    startTime?: string | null
    endTime?: string | null
  }

  export type AvailabilityIntervalCreateOrConnectWithoutContractInput = {
    where: AvailabilityIntervalWhereUniqueInput
    create: XOR<AvailabilityIntervalCreateWithoutContractInput, AvailabilityIntervalUncheckedCreateWithoutContractInput>
  }

  export type AvailabilityIntervalCreateManyContractInputEnvelope = {
    data: AvailabilityIntervalCreateManyContractInput | AvailabilityIntervalCreateManyContractInput[]
    skipDuplicates?: boolean
  }

  export type AmendmentCreateWithoutContractInput = {
    id?: string
    startDate: Date | string
    endDate?: Date | string | null
    newHoursPerWeek?: number | null
    isTemporary: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AmendmentUncheckedCreateWithoutContractInput = {
    id?: string
    startDate: Date | string
    endDate?: Date | string | null
    newHoursPerWeek?: number | null
    isTemporary: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AmendmentCreateOrConnectWithoutContractInput = {
    where: AmendmentWhereUniqueInput
    create: XOR<AmendmentCreateWithoutContractInput, AmendmentUncheckedCreateWithoutContractInput>
  }

  export type AmendmentCreateManyContractInputEnvelope = {
    data: AmendmentCreateManyContractInput | AmendmentCreateManyContractInput[]
    skipDuplicates?: boolean
  }

  export type EmployeeUpsertWithoutContractsInput = {
    update: XOR<EmployeeUpdateWithoutContractsInput, EmployeeUncheckedUpdateWithoutContractsInput>
    create: XOR<EmployeeCreateWithoutContractsInput, EmployeeUncheckedCreateWithoutContractsInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutContractsInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutContractsInput, EmployeeUncheckedUpdateWithoutContractsInput>
  }

  export type EmployeeUpdateWithoutContractsInput = {
    id?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    matricule?: NullableIntFieldUpdateOperationsInput | number | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: NullableEnumSexFieldUpdateOperationsInput | $Enums.Sex | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    address2?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    iban?: NullableStringFieldUpdateOperationsInput | string | null
    bic?: NullableStringFieldUpdateOperationsInput | string | null
    socialSecurityNumber?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    transportMeans?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timeRecords?: TimeRecordUpdateManyWithoutEmployeeNestedInput
    shifts?: ShiftUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutContractsInput = {
    id?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    matricule?: NullableIntFieldUpdateOperationsInput | number | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: NullableEnumSexFieldUpdateOperationsInput | $Enums.Sex | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    address2?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    iban?: NullableStringFieldUpdateOperationsInput | string | null
    bic?: NullableStringFieldUpdateOperationsInput | string | null
    socialSecurityNumber?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    transportMeans?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timeRecords?: TimeRecordUncheckedUpdateManyWithoutEmployeeNestedInput
    shifts?: ShiftUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type AvailabilityIntervalUpsertWithWhereUniqueWithoutContractInput = {
    where: AvailabilityIntervalWhereUniqueInput
    update: XOR<AvailabilityIntervalUpdateWithoutContractInput, AvailabilityIntervalUncheckedUpdateWithoutContractInput>
    create: XOR<AvailabilityIntervalCreateWithoutContractInput, AvailabilityIntervalUncheckedCreateWithoutContractInput>
  }

  export type AvailabilityIntervalUpdateWithWhereUniqueWithoutContractInput = {
    where: AvailabilityIntervalWhereUniqueInput
    data: XOR<AvailabilityIntervalUpdateWithoutContractInput, AvailabilityIntervalUncheckedUpdateWithoutContractInput>
  }

  export type AvailabilityIntervalUpdateManyWithWhereWithoutContractInput = {
    where: AvailabilityIntervalScalarWhereInput
    data: XOR<AvailabilityIntervalUpdateManyMutationInput, AvailabilityIntervalUncheckedUpdateManyWithoutContractInput>
  }

  export type AvailabilityIntervalScalarWhereInput = {
    AND?: AvailabilityIntervalScalarWhereInput | AvailabilityIntervalScalarWhereInput[]
    OR?: AvailabilityIntervalScalarWhereInput[]
    NOT?: AvailabilityIntervalScalarWhereInput | AvailabilityIntervalScalarWhereInput[]
    id?: StringFilter<"AvailabilityInterval"> | string
    day?: EnumDayOfWeekFilter<"AvailabilityInterval"> | $Enums.DayOfWeek
    allDay?: BoolFilter<"AvailabilityInterval"> | boolean
    startTime?: StringNullableFilter<"AvailabilityInterval"> | string | null
    endTime?: StringNullableFilter<"AvailabilityInterval"> | string | null
    contractId?: StringFilter<"AvailabilityInterval"> | string
  }

  export type AmendmentUpsertWithWhereUniqueWithoutContractInput = {
    where: AmendmentWhereUniqueInput
    update: XOR<AmendmentUpdateWithoutContractInput, AmendmentUncheckedUpdateWithoutContractInput>
    create: XOR<AmendmentCreateWithoutContractInput, AmendmentUncheckedCreateWithoutContractInput>
  }

  export type AmendmentUpdateWithWhereUniqueWithoutContractInput = {
    where: AmendmentWhereUniqueInput
    data: XOR<AmendmentUpdateWithoutContractInput, AmendmentUncheckedUpdateWithoutContractInput>
  }

  export type AmendmentUpdateManyWithWhereWithoutContractInput = {
    where: AmendmentScalarWhereInput
    data: XOR<AmendmentUpdateManyMutationInput, AmendmentUncheckedUpdateManyWithoutContractInput>
  }

  export type AmendmentScalarWhereInput = {
    AND?: AmendmentScalarWhereInput | AmendmentScalarWhereInput[]
    OR?: AmendmentScalarWhereInput[]
    NOT?: AmendmentScalarWhereInput | AmendmentScalarWhereInput[]
    id?: StringFilter<"Amendment"> | string
    contractId?: StringFilter<"Amendment"> | string
    startDate?: DateTimeFilter<"Amendment"> | Date | string
    endDate?: DateTimeNullableFilter<"Amendment"> | Date | string | null
    newHoursPerWeek?: IntNullableFilter<"Amendment"> | number | null
    isTemporary?: BoolFilter<"Amendment"> | boolean
    createdAt?: DateTimeFilter<"Amendment"> | Date | string
    updatedAt?: DateTimeFilter<"Amendment"> | Date | string
  }

  export type ContractCreateWithoutAvailabilityInput = {
    id?: string
    contractType?: string | null
    role?: string | null
    hoursPerWeek?: number | null
    status?: $Enums.ContractStatus | null
    resignationDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employee: EmployeeCreateNestedOneWithoutContractsInput
    amendments?: AmendmentCreateNestedManyWithoutContractInput
  }

  export type ContractUncheckedCreateWithoutAvailabilityInput = {
    id?: string
    contractType?: string | null
    role?: string | null
    hoursPerWeek?: number | null
    status?: $Enums.ContractStatus | null
    resignationDate?: Date | string | null
    endDate?: Date | string | null
    employeeId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    amendments?: AmendmentUncheckedCreateNestedManyWithoutContractInput
  }

  export type ContractCreateOrConnectWithoutAvailabilityInput = {
    where: ContractWhereUniqueInput
    create: XOR<ContractCreateWithoutAvailabilityInput, ContractUncheckedCreateWithoutAvailabilityInput>
  }

  export type ContractUpsertWithoutAvailabilityInput = {
    update: XOR<ContractUpdateWithoutAvailabilityInput, ContractUncheckedUpdateWithoutAvailabilityInput>
    create: XOR<ContractCreateWithoutAvailabilityInput, ContractUncheckedCreateWithoutAvailabilityInput>
    where?: ContractWhereInput
  }

  export type ContractUpdateToOneWithWhereWithoutAvailabilityInput = {
    where?: ContractWhereInput
    data: XOR<ContractUpdateWithoutAvailabilityInput, ContractUncheckedUpdateWithoutAvailabilityInput>
  }

  export type ContractUpdateWithoutAvailabilityInput = {
    id?: StringFieldUpdateOperationsInput | string
    contractType?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    hoursPerWeek?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumContractStatusFieldUpdateOperationsInput | $Enums.ContractStatus | null
    resignationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneRequiredWithoutContractsNestedInput
    amendments?: AmendmentUpdateManyWithoutContractNestedInput
  }

  export type ContractUncheckedUpdateWithoutAvailabilityInput = {
    id?: StringFieldUpdateOperationsInput | string
    contractType?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    hoursPerWeek?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumContractStatusFieldUpdateOperationsInput | $Enums.ContractStatus | null
    resignationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employeeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    amendments?: AmendmentUncheckedUpdateManyWithoutContractNestedInput
  }

  export type EmployeeCreateWithoutTimeRecordsInput = {
    id?: string
    lastName?: string
    firstName?: string
    matricule?: number | null
    dateOfBirth?: Date | string | null
    sex?: $Enums.Sex | null
    nationality?: string | null
    address?: string | null
    address2?: string | null
    postalCode?: string | null
    city?: string | null
    iban?: string | null
    bic?: string | null
    socialSecurityNumber?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    transportMeans?: string | null
    photoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contracts?: ContractCreateNestedManyWithoutEmployeeInput
    shifts?: ShiftCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutTimeRecordsInput = {
    id?: string
    lastName?: string
    firstName?: string
    matricule?: number | null
    dateOfBirth?: Date | string | null
    sex?: $Enums.Sex | null
    nationality?: string | null
    address?: string | null
    address2?: string | null
    postalCode?: string | null
    city?: string | null
    iban?: string | null
    bic?: string | null
    socialSecurityNumber?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    transportMeans?: string | null
    photoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contracts?: ContractUncheckedCreateNestedManyWithoutEmployeeInput
    shifts?: ShiftUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutTimeRecordsInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutTimeRecordsInput, EmployeeUncheckedCreateWithoutTimeRecordsInput>
  }

  export type EmployeeUpsertWithoutTimeRecordsInput = {
    update: XOR<EmployeeUpdateWithoutTimeRecordsInput, EmployeeUncheckedUpdateWithoutTimeRecordsInput>
    create: XOR<EmployeeCreateWithoutTimeRecordsInput, EmployeeUncheckedCreateWithoutTimeRecordsInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutTimeRecordsInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutTimeRecordsInput, EmployeeUncheckedUpdateWithoutTimeRecordsInput>
  }

  export type EmployeeUpdateWithoutTimeRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    matricule?: NullableIntFieldUpdateOperationsInput | number | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: NullableEnumSexFieldUpdateOperationsInput | $Enums.Sex | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    address2?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    iban?: NullableStringFieldUpdateOperationsInput | string | null
    bic?: NullableStringFieldUpdateOperationsInput | string | null
    socialSecurityNumber?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    transportMeans?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contracts?: ContractUpdateManyWithoutEmployeeNestedInput
    shifts?: ShiftUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutTimeRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    matricule?: NullableIntFieldUpdateOperationsInput | number | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: NullableEnumSexFieldUpdateOperationsInput | $Enums.Sex | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    address2?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    iban?: NullableStringFieldUpdateOperationsInput | string | null
    bic?: NullableStringFieldUpdateOperationsInput | string | null
    socialSecurityNumber?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    transportMeans?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contracts?: ContractUncheckedUpdateManyWithoutEmployeeNestedInput
    shifts?: ShiftUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeCreateWithoutShiftsInput = {
    id?: string
    lastName?: string
    firstName?: string
    matricule?: number | null
    dateOfBirth?: Date | string | null
    sex?: $Enums.Sex | null
    nationality?: string | null
    address?: string | null
    address2?: string | null
    postalCode?: string | null
    city?: string | null
    iban?: string | null
    bic?: string | null
    socialSecurityNumber?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    transportMeans?: string | null
    photoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contracts?: ContractCreateNestedManyWithoutEmployeeInput
    timeRecords?: TimeRecordCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutShiftsInput = {
    id?: string
    lastName?: string
    firstName?: string
    matricule?: number | null
    dateOfBirth?: Date | string | null
    sex?: $Enums.Sex | null
    nationality?: string | null
    address?: string | null
    address2?: string | null
    postalCode?: string | null
    city?: string | null
    iban?: string | null
    bic?: string | null
    socialSecurityNumber?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    transportMeans?: string | null
    photoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contracts?: ContractUncheckedCreateNestedManyWithoutEmployeeInput
    timeRecords?: TimeRecordUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutShiftsInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutShiftsInput, EmployeeUncheckedCreateWithoutShiftsInput>
  }

  export type EmployeeUpsertWithoutShiftsInput = {
    update: XOR<EmployeeUpdateWithoutShiftsInput, EmployeeUncheckedUpdateWithoutShiftsInput>
    create: XOR<EmployeeCreateWithoutShiftsInput, EmployeeUncheckedCreateWithoutShiftsInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutShiftsInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutShiftsInput, EmployeeUncheckedUpdateWithoutShiftsInput>
  }

  export type EmployeeUpdateWithoutShiftsInput = {
    id?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    matricule?: NullableIntFieldUpdateOperationsInput | number | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: NullableEnumSexFieldUpdateOperationsInput | $Enums.Sex | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    address2?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    iban?: NullableStringFieldUpdateOperationsInput | string | null
    bic?: NullableStringFieldUpdateOperationsInput | string | null
    socialSecurityNumber?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    transportMeans?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contracts?: ContractUpdateManyWithoutEmployeeNestedInput
    timeRecords?: TimeRecordUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutShiftsInput = {
    id?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    matricule?: NullableIntFieldUpdateOperationsInput | number | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: NullableEnumSexFieldUpdateOperationsInput | $Enums.Sex | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    address2?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    iban?: NullableStringFieldUpdateOperationsInput | string | null
    bic?: NullableStringFieldUpdateOperationsInput | string | null
    socialSecurityNumber?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    transportMeans?: NullableStringFieldUpdateOperationsInput | string | null
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contracts?: ContractUncheckedUpdateManyWithoutEmployeeNestedInput
    timeRecords?: TimeRecordUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type ContractCreateWithoutAmendmentsInput = {
    id?: string
    contractType?: string | null
    role?: string | null
    hoursPerWeek?: number | null
    status?: $Enums.ContractStatus | null
    resignationDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employee: EmployeeCreateNestedOneWithoutContractsInput
    availability?: AvailabilityIntervalCreateNestedManyWithoutContractInput
  }

  export type ContractUncheckedCreateWithoutAmendmentsInput = {
    id?: string
    contractType?: string | null
    role?: string | null
    hoursPerWeek?: number | null
    status?: $Enums.ContractStatus | null
    resignationDate?: Date | string | null
    endDate?: Date | string | null
    employeeId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    availability?: AvailabilityIntervalUncheckedCreateNestedManyWithoutContractInput
  }

  export type ContractCreateOrConnectWithoutAmendmentsInput = {
    where: ContractWhereUniqueInput
    create: XOR<ContractCreateWithoutAmendmentsInput, ContractUncheckedCreateWithoutAmendmentsInput>
  }

  export type ContractUpsertWithoutAmendmentsInput = {
    update: XOR<ContractUpdateWithoutAmendmentsInput, ContractUncheckedUpdateWithoutAmendmentsInput>
    create: XOR<ContractCreateWithoutAmendmentsInput, ContractUncheckedCreateWithoutAmendmentsInput>
    where?: ContractWhereInput
  }

  export type ContractUpdateToOneWithWhereWithoutAmendmentsInput = {
    where?: ContractWhereInput
    data: XOR<ContractUpdateWithoutAmendmentsInput, ContractUncheckedUpdateWithoutAmendmentsInput>
  }

  export type ContractUpdateWithoutAmendmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    contractType?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    hoursPerWeek?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumContractStatusFieldUpdateOperationsInput | $Enums.ContractStatus | null
    resignationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneRequiredWithoutContractsNestedInput
    availability?: AvailabilityIntervalUpdateManyWithoutContractNestedInput
  }

  export type ContractUncheckedUpdateWithoutAmendmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    contractType?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    hoursPerWeek?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumContractStatusFieldUpdateOperationsInput | $Enums.ContractStatus | null
    resignationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employeeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    availability?: AvailabilityIntervalUncheckedUpdateManyWithoutContractNestedInput
  }

  export type ContractCreateManyEmployeeInput = {
    id?: string
    contractType?: string | null
    role?: string | null
    hoursPerWeek?: number | null
    status?: $Enums.ContractStatus | null
    resignationDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TimeRecordCreateManyEmployeeInput = {
    id?: string
    date: Date | string
    checkIn: Date | string
    checkOut?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShiftCreateManyEmployeeInput = {
    id?: string
    date: Date | string
    startHour: number
    endHour: number
    shiftType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContractUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    contractType?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    hoursPerWeek?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumContractStatusFieldUpdateOperationsInput | $Enums.ContractStatus | null
    resignationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    availability?: AvailabilityIntervalUpdateManyWithoutContractNestedInput
    amendments?: AmendmentUpdateManyWithoutContractNestedInput
  }

  export type ContractUncheckedUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    contractType?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    hoursPerWeek?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumContractStatusFieldUpdateOperationsInput | $Enums.ContractStatus | null
    resignationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    availability?: AvailabilityIntervalUncheckedUpdateManyWithoutContractNestedInput
    amendments?: AmendmentUncheckedUpdateManyWithoutContractNestedInput
  }

  export type ContractUncheckedUpdateManyWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    contractType?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    hoursPerWeek?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumContractStatusFieldUpdateOperationsInput | $Enums.ContractStatus | null
    resignationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TimeRecordUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    checkIn?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TimeRecordUncheckedUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    checkIn?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TimeRecordUncheckedUpdateManyWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    checkIn?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShiftUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startHour?: FloatFieldUpdateOperationsInput | number
    endHour?: FloatFieldUpdateOperationsInput | number
    shiftType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShiftUncheckedUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startHour?: FloatFieldUpdateOperationsInput | number
    endHour?: FloatFieldUpdateOperationsInput | number
    shiftType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShiftUncheckedUpdateManyWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startHour?: FloatFieldUpdateOperationsInput | number
    endHour?: FloatFieldUpdateOperationsInput | number
    shiftType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AvailabilityIntervalCreateManyContractInput = {
    id?: string
    day: $Enums.DayOfWeek
    allDay: boolean
    startTime?: string | null
    endTime?: string | null
  }

  export type AmendmentCreateManyContractInput = {
    id?: string
    startDate: Date | string
    endDate?: Date | string | null
    newHoursPerWeek?: number | null
    isTemporary: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AvailabilityIntervalUpdateWithoutContractInput = {
    id?: StringFieldUpdateOperationsInput | string
    day?: EnumDayOfWeekFieldUpdateOperationsInput | $Enums.DayOfWeek
    allDay?: BoolFieldUpdateOperationsInput | boolean
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AvailabilityIntervalUncheckedUpdateWithoutContractInput = {
    id?: StringFieldUpdateOperationsInput | string
    day?: EnumDayOfWeekFieldUpdateOperationsInput | $Enums.DayOfWeek
    allDay?: BoolFieldUpdateOperationsInput | boolean
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AvailabilityIntervalUncheckedUpdateManyWithoutContractInput = {
    id?: StringFieldUpdateOperationsInput | string
    day?: EnumDayOfWeekFieldUpdateOperationsInput | $Enums.DayOfWeek
    allDay?: BoolFieldUpdateOperationsInput | boolean
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AmendmentUpdateWithoutContractInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    newHoursPerWeek?: NullableIntFieldUpdateOperationsInput | number | null
    isTemporary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AmendmentUncheckedUpdateWithoutContractInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    newHoursPerWeek?: NullableIntFieldUpdateOperationsInput | number | null
    isTemporary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AmendmentUncheckedUpdateManyWithoutContractInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    newHoursPerWeek?: NullableIntFieldUpdateOperationsInput | number | null
    isTemporary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}